# 0. Abstract
QUIC具有HTTP传输层协议所需的几个特性：流多路复用、逐流流控及低时延连接建立。本文描述了HTTP语义在QUIC上的映射，同时也描述了QUIC协议中来自HTTP/2的特性，并说明了HTTP/2扩展如何移植到HTTP/3。

# 1. Introduction

互联网上大量服务使用了HTTP语义，这些语义通常在HTTP/1.1和HTTP/2协议层上表示。HTTP/1.1基于各种传输层和会话层协议，而HTTP/2主要由TCP之上的TLS层承载。HTTP/3在一个新的传输层协议QUIC上支持了相同的语义。

## 1.1. Prior versions of HTTP

HTTP/1.1（[[HTTP/1.1]](#http1)）使用以空格分隔的文本字段来表示HTTP消息。虽然这种方式的可读性较好，但是使用空白来格式化消息，会增加解析的复杂度和面对更多变数。

由于HTTP/1.1不包括多路复用层，所以经常使用多个并发的TCP连接发送请求。这对拥塞控制和网络效率有负面影响，因为TCP不会跨连接共享拥塞控制。

HTTP/2（[[HTTP/2]](#http2)）引入了二进制组帧和多路复用层，从而可以在不修改传输层的前提下改善延迟。然而，因为HTTP/2多路复用的并发原理对于TCP的丢包恢复机制是不可见的，一个数据包的丢失或乱序就会导致所有活动的事务暂停，而不管事务是否受到这个数据包的影响。

## 1.2. Delegation to QUIC

QUIC传输层协议纳入了流多路复用和逐流流控，与HTTP/2组帧层提供的特性类似。通过在stream层提供可靠性，在整个连接上提供拥塞控制，相对于TCP，QUIC有能力改善HTTP的性能。
QUIC同样在传输层引入了TLS 1.3（[[TLS]](#tls)），提供了与TLS over TCP同等的机密性和完整性保护，改善了TCP快速打开[[TFO]](#tfo)带来的建连延迟。

本文定义了一种基于QUIC传输协议的HTTP语义映射方式，主要借鉴了HTTP/2的设计。HTTP/3依靠QUIC提供数据的机密性和完整性保护、身份验证，以及流上的可靠有序传输。HTTP/3将流的生命周期和流控管理委托给了QUIC，每条流上也采用了与HTTP/2类似的二进制组帧方式。部分HTTP/2特性归入到QUIC协议中，其余的特性仍由QUIC的上层（HTTP/3协议）实现。

QUIC核心协议参见[[QUIC-TRANSPORT]](#quic)，HTTP/2完整说明参见[[HTTP/2]](#http2)。

# 2. HTTP/3 Protocol Overview

HTTP/3通过QUIC协议传输HTTP语义，并提供了类似HTTP/2的内部组帧层。

一旦客户端得知某个指定终端上支持HTTP/3服务，它就可以打开一个QUIC连接。QUIC提供了协议协商，基于流的多路复用以及流控。3.1节中描述了如何发现HTTP/3终端。

在每条流中，HTTP/3通信的基本单元是帧（frame，参见7.2节）。不同帧类型对应不同的用途。比如，HTTP请求和响应由HEADERS和DATA帧承载（参考4.1节），适用于整个连接的帧在专用的控制流上传输。

在[[QUIC-TRANSPORT]](#quic)第2章中，描述了如何使用QUIC流来实现请求的多路复用。每个request-response对由一条QUIC流承载。流之间是独立的，一条流上出现丢包或阻塞不会影响其他流的前进。

服务端推送（Server push）是由HTTP/2（[[HTTP/2]](#http2)）引入的交互模式，这种模式允许服务端在客户端发送request消息之前提前推送预测的response。这是在牺牲网络利用率但获得潜在延迟收益之间做的取舍。HTTP/3使用了一些帧来实施服务端推送功能，比如PUSH_PROMISE，MAX_PUSH_ID以及CANCEL_PUSH。

在HTTP/2中，request与response字段遵循HPACK协议进行头压缩后再传输。因为HPACK [[HPACK]](#hpack)要求连接上所有流数据都保序投递（QUIC不提供这样的保证），所以HTTP/3用QPACK [[QPACK]](#qpack) 协议取代了HPACK。QPACK使用独立的单向流来修改和跟踪field表状态，而（数据流上的）encoded field段只引用表状态而不做修改。

## 2.1. Document Organization

以下章节提供了HTTP/3连接的生命周期详细概述：

* “连接建立和管理”（第3章）涵盖了如何发现HTTP/3终端，以及如何建立HTTP/3连接。
* “用HTTP/3表示HTTP语义”（第4章）描述了如何使用帧来表示HTTP语义。
* “连接关闭”（第5章）描述了如何关闭HTTP/3连接，包括优雅关闭和立即关闭。

以下章节描述了上层协议与传输的交互细节：

* “stream映射方式与用法”（第6章）描述了QUIC流的使用方式。
* “HTTP组帧层”（第7章）描述了在大多数流上使用的帧类型。
* “错误处理”（第8章）描述了如何处理和表示错误条件，无论是在特定流上还是整个连接上。

最后章节提供了如下资源：

* “HTTP/3扩展”（第9章）描述了如何在未来的文档中添加新功能。
* 附录A提供了HTTP/2 与 HTTP/3之间更具体的对比。

## 2.2. Conventions and Terminology

终止（abort）：连接或流的立即终止，可能由错误条件引起。

客户端（client）：发起HTTP/3连接的终端。客户端发送HTTP请求，并接受HTTP响应。

连接（connection）：两个终端之间的传输层连接，使用QUIC作为传输层协议。

连接错误（connection error）：影响整个HTTP/3连接的错误。

终端（endpoint）：连接的客户端或者服务端。

帧（frame）：HTTP/3在流上通信时的最小单元，包含一个帧头和一个根据帧类型组织的变长字节序列。
本文和[[QUIC-TRANSPORT]](#quic)中都存在称为“帧”的协议元素。当提及[[QUIC-TRANSPORT]](#quic)中的帧时，帧的名字之前会添加前缀“QUIC”。比如，“QUIC CONNECTION_CLOSE 帧”。没有这个前缀的帧均指7.2节中定义的帧。

HTTP/3连接（HTTP/3 connection）：一个QUIC连接，其上协商的应用层协议是HTTP/3。

对端（peer）：一个终端。当提及某个终端时，"对端"指的是与当前讨论对象遥相对应的终端。

接收端（receiver）：正在接收帧的终端。

发送端（sender）：正在发送帧的终端。

服务端：接受HTTP/3连接的终端。 服务端接收HTTP请求，并发送HTTP响应。

流（stream）：QUIC传输提供的一个双向或者单向的字节流。一个HTTP/3连接内的所有流都可以被认为是"HTTP/3流"，但HTTP/3内定义了多种流类型。

流错误（stream error）：个别HTTP/3流上的应用级（application-level）错误。

术语 "content" 在 [[HTTP]](#http) 第6.4节中定义。

最后，术语 "resource"、"message"、"user agent"、"origin server"、"gateway"、"intermediary"、"proxy" 和 "tunnel"在 [[HTTP]](#http) 第3章中定义。

本文中的数据包图表使用 [[QUIC-TRANSPORT]](#quic) 第1.3节中定义的格式来说明字段的顺序和大小。

# 3. Connection Setup and Management

## 3.1. Discovering an HTTP/3 Endpoint

HTTP依赖于权威响应的概念：一个由目标URI标识所确定的服务端的响应，是在给定响应消息生成时的目标资源状态下，该请求的最合适的响应。在 [[HTTP]](#http) 的4.3节中讨论了如何给一个HTTP URI确定权威服务端。

“Https”模式将权限和证书结合起来，其中客户端认为（通过URI的权威模块识别的）主机的证书是可信的。在收到TLS握手的服务端证书后，客户端必须（**MUST**）使用[[HTTP]](#http)第4.3.4节中描述的过程来验证该证书是否与URI的源服务端相匹配。如果该证书不能对URI的源服务端进行验证，客户端不得（**MUST NOT**）考虑该服务端对该源的权威性。

客户端可以（**MAY**）使用带“https”的URI来访问资源：首先将主机标识解析为IP地址，接着建立一个到这个地址和指定端口的QUIC连接（包括上述服务端证书的验证），然后在这个安全的连接上发送一个将URI指向该服务端的HTTP/3请求消息。除非有其他机制选择HTTP/3，我们在TLS握手过程中，在应用层协议协商（ALPN；见[[RFC7301]](#rfc7301)）扩展中使用"h3"标识来选择HTTP/3协议。

连通性问题（例如，UDP阻塞）可能导致QUIC建连失败；这种情况下客户端应当（**SHOULD**）尝试使用基于TCP的HTTP版本。

服务端可以（**MAY**）在任意UDP端口上开启HTTP/3服务；一个可选的服务通告通常包含一个显式指定的端口，其URI包含一个显式端口或者使用基于此模式的默认端口（译者注：如http默认80端口，https默认433端口）。

### 3.1.1. HTTP Alternative Services

终端可以通过HTTP/1 Alt-Svc响应头或者HTTP/2 ALTSVC帧宣告自己支持HTTP/3。

例如如下格式的响应头表示相同主机下的50781端口支持HTTP/3：

Alt-Svc: h3=":50781" 

当接收到表明支持HTTP/3的响应头时，客户端可以（**MAY**）尝试在给定的主机IP和端口上建立QUIC连接，如果连接建立成功，客户端可以使用本文中描述的对应方式发送HTTP请求。

### 3.1.2. Other Schemes

尽管HTTP独立于传输协议，但“http”模式将权限和在权限模块认证的，任意主机的指定端口上，接收TCP连接的能力结合起来。由于HTTP/3不使用TCP，因此它无法直接访问权威服务端上由“http”URI标识的资源。尽管如此，诸如[[ALTSVR]](#altsvr)的协议扩展允许权威服务端识别其他同样具有权威性且可通过HTTP/3访问的服务。

在对不是“https”模式的源发送请求之前，客户端必须（**MUST**）确认服务端愿意为该模式提供服务。
对于“http”模式的源，[[RFC8164]](#rfc8164)中描述了一种实验性的方法来实现这一目标。将来也可能会为其他模式定义对应机制。

## 3.2 Connection Establishment

HTTP/3目前依赖QUIC version 1作为底层传输，将来的规范可能（**MAY**）会定义HTTP/3使用的其他QUIC版本。

QUIC握手协议版本大于等于TLS 1.3。HTTP/3客户端必须（**MUST**）支持在TLS握手期间向服务端指示目的主机的机制。如果服务端由域名（[[DNS-TERMS]](#dns-terms)）标识，则客户端必须（**MUST**）发送服务端名称指示（SNI; [[RFC6066]](#rfc6066)）TLS扩展，除非使用了其他指示目的主机的替代机制。

QUIC连接的建立如 [[QUIC-TRANSPORT]](#quic) 所述。在建立连接的过程中，TLS 握手中 ALPN 标识 "h3" 用来表明是否支持HTTP/3。对其他应用层协议的支持也可以（**MAY**）在这次握手中提供。

虽然与核心QUIC协议有关的连接级选项是在初始加密握手中设置的，但HTTP/3特定的设置项是在SETTINGS帧中表示的。在建立QUIC连接后，每个终端必须（**MUST**）在相应的HTTP控制流上发送一个SETTINGS帧作为初始帧。

## 3.3. Connection Reuse

HTTP/3连接可用于多个请求。为了性能考虑，客户端一般不会主动关闭连接，除非客户端认为不再需要继续和服务端进行通信（比如，用户离开相应web页），或者直到服务端关闭连接。

一旦建立上与服务端的连接，该连接可以（**MAY**）用于请求其他URI，只要服务端是经过认证的。要将现有连接用于新的源，客户端必须（**MUST**）通过 [[HTTP]](#http) 第4.3.4节中所述的过程，来验证服务端为新的源服务端提供的证书。这意味着客户端将需要保留服务端证书以及验证该证书所需的任何其他信息，不这样做的客户端将无法为其他的源重用该连接。

如果证书因一些原因不能被新源接受，则该连接不得（**MUST NOT**）被重用，应该（**SHOULD**）为新源建立新连接。如果证书验证不通过的原因也可能适用于其他与此连接相关联的源，则客户端应该（**SHOULD**）为这些源重新验证服务端证书。例如，如果因为过期或被撤销的原因导致证书验证失败，则可能导致使用该证书进行授权的所有其他源失效。

客户端不应（**SHOULD NOT**）打开多个到给定IP地址和UDP端口的HTTP/3连接，其中IP地址和端口可能来自URI、选定的替代服务（[[ALTSVC]](#altsvc)）、配置的代理或名称解析中的任何一个。客户端可以（**MAY**）使用不同的传输或TLS配置打开到相同IP地址和UDP端口的多个HTTP/3连接，但应避免使用相同配置创建多个连接。

建议服务端尽可能长地维护HTTP/3连接，但在必要时允许终止空闲连接。如果任一终端选择关闭HTTP/3连接，它应该（**SHOULD**）先发送一个GOAWAY帧（5.2节），这样两端可以明确知道之前发送的帧是否已被处理，且可以优雅完成或终止剩下的所有任务。

如果服务端不希望客户端针对特定来源复用HTTP/3连接，可以通过在请求响应中发送421（错误定向请求）状态码来表明该请求对服务端不具有权威性（见 [[HTTP]](#http) 的7.4节）

# 4. Expressing HTTP Semantics in HTTP/3

## 4.1. HTTP Message Framing

客户端在其发起的双向QUIC流上发送HTTP请求，见第 6.1 节。客户端必须（**MUST**）在给定的请求流上只发送一个请求，服务端在此流上发送零到多个中间HTTP响应，最后接一个最终HTTP响应，如下所述。关于中间和最终HTTP响应的描述，请参见[[HTTP]](#http)的第15章。

推送的响应在由服务端发起的单向QUIC流上进行发送，参见6.2.2小节。与标准的响应方式一样，服务端先发送零到多个中间HTTP响应，最后接一个最终HTTP响应。在4.6节中有对推送做更详尽的描述。

如果在给定的流上收到多个请求，或者在最终HTTP响应之后再收到一个HTTP响应，则必须（**MUST**）将这种情况视为异常。

一个HTTP消息（请求或响应）由以下内容组成：

1. 头部段：包含控制消息，由单个HEADERS帧发送；
2. （可选项）载荷：如果存在，由一系列DATA帧发送；
3. （可选项）尾部段：如果存在，由单个HEADERS帧发送；

头部段和尾部段分别在 [[HTTP]](#http) 的6.3和6.5节中描述，载荷在 [[HTTP]](#http) 的6.4节中有说明。

如果收到一系列无效帧，必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误（第8章）。特别是，在HEADERS帧之前收到DATA帧，在尾部HEADERS帧之后收到HEADERS或DATA帧，都是无效的。其他帧类型（尤其是未知帧类型）可能由其自身规则是容许的，参见第9章。

服务端可以（**MAY**）在响应消息帧之前、之后、中间发送一个或多个PUSH_PROMISE帧。这些PUSH_PROMISE帧不是响应的一部分（参考4.6节）。PUSH_PROMISE帧不允许出现在推送流中；必须（**MUST**）把包含PUSH_PROMISE的推送响应视为H3_FRAME_UNEXPECTED类型的连接错误。

在一个请求或者推送流上，未知类型的帧（第9章），包括保留帧（第7.2.8小节），可以（**MAY**）在本章描述的其他帧之前、之后、中间交替发送。

HEADERS和PUSH_PROMISE帧可能引用QPACK动态表的更新。虽然这些更新不是消息交换的直接部分，但是他们必须在消息消费前被接收并处理，详情参考 4.2节。

HTTP/3未定义传输编码（请参见[[HTTP/1.1]](#http1)第7章），因此不得（**MUST NOT**）使用Transfer-Encoding标头字段。

响应可以（**MAY**）包含多个消息 当且仅当 在同一个请求中，最终响应消息之前有一个或多个中间响应消息（1xx，参考 [[HTTP]](#http) 第15.2节）。中间响应消息不包含载荷或尾部段。

一个HTTP请求/响应交换完全占用客户端发起的双向QUIC流。在发送请求之后，客户端必须（**MUST**）关闭流的发送。除非使用CONNECT方法（参考4.4节），否则客户端不得（**MUST NOT**）由接收到对应响应来决定关闭流。在发送最终响应之后，服务端必须（**MUST**）关闭流的发送。此刻，QUIC流就完全关闭了。

当一个流关闭时，这表示最终HTTP消息的结束。由于某些消息很大或无上限，终端应该（**SHOULD**）在收到足够长度的消息可以进行后续动作时开始处理这部分HTTP消息。如果客户端发起的流，在没有发送足够长度的HTTP请求消息，服务端不能给出完整响应的情况下终止，则服务端应该（**SHOULD**）中止其响应流并返回错误码H3_REQUEST_INCOMPLETE。

如果响应不取决于尚未发送和接收的请求的任何部分，则服务端可以在客户端发送完整个请求之前发送完整的响应。当服务端不需要接收请求的剩余部分时，它可能（**MAY**）会中止读取请求流，发送完整的响应，并干脆地关闭流的发送部分。请求客户端停止在请求流上发送时应该（**SHOULD**）使用错误码H3_NO_ERROR。客户端不得（**MUST NOT**）因为他们的请求被立即终止而丢弃完整的响应，不过出于其他原因，其自行决定丢弃响应。如果服务端发送了部分或完整的响应但没有中止读取请求，客户端应该（**SHOULD**）继续发送请求的载荷并正常关闭流。

### 4.1.1. Request Cancellation and Rejection

一旦请求流已经打开，任一终端都可以（**MAY**）关闭它。如果对响应不再感兴趣，客户端可以关闭流，如果服务端无法响应或选择不响应，则服务端也可以取消请求。如果可能，建议（**RECOMMENDED**）服务端发送带有适当状态码的HTTP响应，而不是取消它已经开始处理的请求。

实现应该（**SHOULD**）（SHOULD）通过立即终止仍然打开的流的任何方向来取消请求。为此，实现会重置流的发送部分并中止对流的接收部分的读取；请参阅[[QUIC-TRANSPORT]](#quic)的第2.4节。

当服务端取消请求而不执行任何应用层处理时，该请求被视为“拒绝”。服务端应该（**SHOULD**）以错误码H3_REQUEST_REJECTED 中止其响应流. 在这种情况下，“已处理”意味着来自流的一些数据已经被投递到某些更上层的软件，这些软件可能因此执行了一些动作。客户端可以将被服务端拒绝的请求视为根本没有发送过，因此稍后允许进行重试。

对已经部分或全部处理的请求，服务端不得（**MUST NOT**）返回H3_REQUEST_REJECTED错误码。在服务端在部分处理后放弃响应时，它 应该（**SHOULD**）以错误码H3_REQUEST_CANCELLED中止其响应流。

客户端应该（**SHOULD**）以错误码H3_REQUEST_CANCELLED取消请求。收到此错误码后，如果没有进行任何处理，服务端可以（**MAY**）回以错误码H3_REQUEST_REJECTED，并立即终止响应。客户端不得（**MUST NOT**）使用H3_REQUEST_REJECTED错误码，除非服务端以此错误码请求关闭请求流。

如果在收齐完整响应后再取消流，客户端可以（**MAY**）忽略此取消并使用此响应消息。但是，如果在收到部分响应后取消流，则不应使用该响应消息。只有GET、PUT或DELETE等幂等操作可以安全地重试；客户端不应（**SHOULD NOT**）使用非幂等方法自动重试请求，除非它有某种方法可以知道请求语义是独立于方法的幂等操作，或者有某种方法可以检测到原始请求从未被应用。有关详细信息，请参阅[[HTTP]](#http)的第 9.2.2 节。

### 4.1.2.  Malformed Requests and Responses

格式错误的请求或响应是某些方面有效的帧，但由于以下原因而无效：

* 存在禁用的字段或伪标头字段；
* 缺失必选伪标头字段；
* 伪标头字段为无效值；
* 伪标头字段位于其他字段之后；
* HTTP消息错误；
* 字段名包含大写字母；
* 字段名或值中包含无效字符；
  
定义为包含内容的响应类型，如果Content-Length标头字段（[[HTTP]](#http)的第8.6节）的值不等于接收到的DATA帧长度的总和，则认为是格式错误的。定义为从不包含内容的响应类型（即使存在Content-Length）可以具有非零的Content-Length标头字段，即使DATA帧中不包含任何内容也没关系。

处理HTTP请求或响应的中间设备（即任何不充当隧道的中间设备）不得（**MUST NOT**）转发格式错误的请求或响应。检测到格式错误的请求或响应必须（**MUST**）视为H3_MESSAGE_ERROR流错误。

对于格式错误的请求，服务端可以（**MAY**）在关闭或重置流之前发送一个指示错误的HTTP响应。客户端不得（**MUST NOT**）接受格式错误的响应。请注意，这些要求旨在防止针对HTTP的几种常见攻击，这种严格约束是故意为之的，可以防止将实现暴露给这些漏洞。

## 4.2.  HTTP Fields

HTTP消息以一系列称为“HTTP字段”的键值对的方式携带元数据；请参阅[[HTTP]](#http)的第6.3和6.5节。有关已注册HTTP字段列表，请参阅维护于 <https://www.iana.org/assignments/http-fields/> 的“Hypertext Transfer Protocol (HTTP) Field Name Registry”一节。HTTP/3在字段名、连接头字段和伪标头字段中，具有与HTTP/2一样的与字符相关的其他注意事项。

字段名是包含ASCII字符子集的字符串。[[HTTP]](#http)的5.1节更详细地讨论了HTTP字段名和值的属性。字段名中的字符必须（**MUST**）在编码之前转换为小写。字段名中包含大写字符的请求或响应必须（**MUST**）被视为格式错误。

HTTP/3不使用连接头字段来指示连接相关的字段；在此协议中，连接相关的元数据通过其他方式传送。终端不得（**MUST NOT**）生成包含连接相关字段的HTTP/3段；任何包含连接相关字段的消息必须（**MUST**）被视为格式错误。

唯一的例外是TE标头字段，它可以（**MAY**）出现在HTTP/3请求标头中；如果有，它不得（**MUST NOT**）包含除“trailers”之外的其他值。

将HTTP/1.x消息转换为HTTP/3的中间节点必须（**MUST**）删除如[[HTTP]](#http)的第7.6.1节所述的连接相关的头字段，否则它们的消息将被其他HTTP/3终端视为格式错误。

### 4.2.1.  Field Compression
[[QPACK]](#qpack)描述了HPACK协议的一种变更，它使编码器可以（**MAY**）控制压缩导致的队头阻塞量。这使得编码器可以平衡压缩效率和网络延迟。HTTP/3使用QPACK来压缩头部和尾部部分，包括头部部分中的控制数据。

为了提高压缩效率，Cookie标头字段（[[COOKIES]](#cookies)）可以在压缩之前拆分为单独的字段行，每行包含一个或多个cookie对。如果解压缩的字段部分包含多个cookie字段行，则在投递到HTTP/2或HTTP/3以外，如HTTP/1.1连接或通用HTTP服务端应用的上下文之前，必须（**MUST**）使用"; "（ASCII 0x3b，0x20）的两字节分隔符将它们串接成字符串。

### 4.2.2.  Header Size Constraints

HTTP/3实现可以（**MAY**）限制它在单个HTTP消息上可接受的标头的最大长度。收到标头超过此长度的服务端可以发送HTTP431（请求头字段超长 Request Header Fields Too Large）状态码（[[RFC6585]](#rfc6585)）。客户端可以丢弃它无法处理的响应。字段列表的长度是根据未压缩的字段长度计算的，包括名称和值的长度（以字节为单位）加上每个字段32字节的开销。

如果一个实现希望向对端通告此限制，它可以字节为单位设置 SETTINGS_MAX_FIELD_SECTION_SIZE的值。收到此参数的实现不应（**SHOULD NOT**）发送超过指示大小的HTTP消息头，因为对端可能会拒绝处理它。但是，HTTP消息在到达源服务端之前可能经过一个或多个中间设备；请参阅[[HTTP]](#http)的第3.7节。因为这个限制是由处理消息的每个实现单独处理的，所以低于此限制的消息能否被接受也不能保证。

## 4.3. HTTP Control Data

与HTTP/2一样，HTTP/3 使用一系列伪标头字段，其中字段名以“:”字符（ASCII 0x3a）开头。这些伪标头字段表示消息控制数据；请参阅[[HTTP]](#http)的第6.2节。

伪标头字段不是HTTP字段。终端不得（**MUST NOT**）生成除本文定义以外的伪标头字段。但是，有个扩展可以协商修改此限制；见第9章。

伪标头字段仅在定义它们的上下文中有效。为请求定义的伪标头字段不得（**MUST NOT**）出现在响应中；为响应定义的伪标头字段不得（**MUST NOT**）出现在请求中。伪标头字段不得（**MUST NOT**）出现在尾部段中。终端必须（**MUST**）将包含未定义或无效伪标头字段的请求或响应视为格式错误。

在头部段中，所有伪标头字段必须（**MUST**）出现在常规标头字段之前。任何违反此约定的请求或响应必须（**MUST**）被视为格式错误。

### 4.3.1 Pseudo-Header Fields

HTTP/3 为请求消息定义了如下伪标头字段：

* ":method"：包含HTTP方法（[[HTTP]](#http)的第9章）。
* ":scheme"：包含目的URI的模式部分（[[URI]](#uri)的第3.1节）。  
  
    :scheme伪标头不局限于“http”和“https”模式的URI。代理或网关可以转换非HTTP模式的请求，使HTTP能够与非HTTP服务进行交互。

    有关使用“https”以外的模式的指导，请参见第3.1.2节。

* ":authority"：包含目的URI的授权部分（[[URI]](#uri)的第3.2节）。权限不得（**MUST NOT**）包含“http”或“https”模式的URI中已弃用的userinfo子组件。

    为确保如HTTP/1.1请求行可以精确重构出来，当从具有method相关形式HTTP/1.1请求转换过来时，必须（**MUST**）忽略此伪标头字段；请参阅[[HTTP]](#http)的第7.1节。直接生成HTTP/3请求的客户端应该（**SHOULD**）使用:authority伪标头字段而不是Host头字段。如果请求中不存在主机字段，则将HTTP/3请求转换为HTTP/1.1的中间设备必须（**MUST**）通过复制:authority伪标头字段的值来创建主机字段。

* ":path"：包含目的URI的路径和查询部分（“绝对路径”表达式和可选的?字符（ASCII 0x3f），后跟“查询”表达式；参见[[URI]](#uri)的第3.3和3.4节。

    对于“http”或“https”模式的URI，此伪标头字段不得（**MUST NOT**）为空；不包含路径组件的“http”或“https”模式URI必须（**MUST**）包含“/”(ASCII 0x2f)的值。不包含路径组件的OPTIONS请求的:path 伪标头字段包含“*”(ASCII 0x2a) ；请参阅[[HTTP]](#http)的第7.1节。

所有HTTP/3请求必须（**MUST**）只包含一个:method、:scheme 和 :path伪标头字段的值，除非请求是CONNECT请求；见第 4.4节。

如果:scheme伪标头字段指定的是具有必选授权组件（包括“http”和“https”）的模式，则请求必须（**MUST**）包含:authority伪标头字段或Host标头字段。如果字段存在，则不得（**MUST NOT**）为空。如果两个字段都存在，它们必须（**MUST**）包含相同的值。如果该模式没有必选授权组件并且在请求目标中没有提供任何内容，则请求不得（**MUST NOT**）包含:authority伪标头或Host标头字段。

缺失必选伪标头字段或伪标头字段包含无效值的HTTP请求为格式错误。

HTTP/3 没有定义如在HTTP/1.1请求行中携带的版本标识符的方法。HTTP/3请求隐含的协议版本为“3.0”。

### 4.3.2. Response Pseudo-Header Fields
HTTP/3对于响应，定义了一个带有HTTP状态码的“:status”伪标头字段；请参阅[[HTTP]](#http)的第15章。这个伪标头字段必须（**MUST**）包含在所有响应中；否则为响应格式错误（见第4.1.2 节）。

HTTP/3没有定义如在HTTP/1.1状态行中携带的版本或原因短语的方法。HTTP/3响应隐含的协议版本为“3.0”。

## 4.4. The CONNECT Method
CONNECT方法请求接收方建立一条到由request-target标识的目的源服务端的隧道；请参阅[[HTTP]](#http)的第9.3.6节。它主要与HTTP代理一起使用，以与源服务端建立TLS会话，以便与“https”资源进行交互。

在HTTP/1.x中，CONNECT用于将整个HTTP连接转换为到远程主机的隧道。在HTTP/2和HTTP/3中，CONNECT 方法用于在单个流上建立隧道。

一个CONNECT请求必须（**MUST**）有如下格式：

* :method 伪标头字段设置为 "CONNECT"
* :scheme 和 :path 伪标头字段被省略
* :authority 伪标头字段包含要连接的主机和端口（相当于CONNECT请求的request-target的授权形式；参见[[HTTP]](#http)的第7.1节）。

请求流在携带要传输的数据的请求结束前保持打开状态。不遵循这些限制的CONNECT请求格式不正确。

支持CONNECT的代理与:authority伪标头字段标识的服务端建立TCP连接（[[RFC0793]](#rfc0793)）。成功建立此连接后，代理发送给客户端一个包含2xx系列状态码的HEADERS帧，如[[HTTP]](#http)的第15.3节中所定义。

所有数据流上的DATA帧对应于TCP连接上发送或接收的数据。客户端发出的任何DATA帧的有效载荷由代理投递到TCP服务端；从TCP服务端接收到的数据被代理打包成DATA帧。请注意，不能保证TCP段的长度和数量映射到HTTP DATA帧或QUIC STREAM帧时的长度或数量。

一旦CONNECT方法完成，只有DATA帧允许在该流上发送。如果扩展定义特别允许，可以（**MAY**）使用扩展帧。收到任何其他已知帧类型必须（**MUST**）被视为H3_FRAME_UNEXPECTED类型的连接错误。

TCP连接可以由任一终端关闭。当客户端结束请求流时（即代理处的接收流进入“Data Recvd”状态），代理将在其与TCP服务端的连接上设置FIN位。当代理接收到一个设置了FIN位的数据包时，它将关闭它到客户端的发送流。在单个方向上保持半关闭状态的TCP连接并非无效，但服务端通常处理不当，因此客户端在仍期望从CONNECT对端接收数据时，不应（**SHOULD NOT**）关闭用于发送的流。

TCP通过突然终止流来发出连接错误信号。代理将TCP连接中的任何错误（包括接收设置了RST位的TCP段）视为H3_CONNECT_ERROR类型流错误。

相应地，如果代理检测到流或QUIC连接错误，它必须（**MUST**）关闭TCP连接。如果代理检测到客户端已重置流或中止从流中读取，它必须（**MUST**）关闭TCP连接。如果流被重置或读取被客户端中止，代理应该（**SHOULD**）在另一个方向上执行相同的操作，以确保流的两个方向都被取消。在所有这些情况下，如果底层TCP实现允许，代理应该（**SHOULD**）发送一个设置了RST位的TCP段。

由于CONNECT创建了一个到任意服务端的隧道，支持CONNECT的代理应该（**SHOULD**）将其使用限制在一组已知端口或安全请求目标列表；有关详细信息，请参阅[[HTTP]](#http)的第9.3.6节。

## 4.5. HTTP Upgrade
HTTP/3不支持HTTP升级机制（[[HTTP]](#http)的第7.8节）或 101（交换协议）信息状代码（参见[[HTTP]](#http)第15.2.2节）。

## 4.6. Server Push
服务端推送是一种交互模式，它允许服务端在客户端发出请求之前，将请求-响应交换报文推送到客户端。这是在牺牲网络利用率但获得潜在延迟收益之间做的取舍。HTTP/3服务端推送类似于[[HTTP/2]](#http2)8.2节中描述的内容，但它使用不同的机制。

每个服务端推送都由服务端分配一个唯一的push ID。push ID用于在HTTP/3连接的整个生命周期中在各种上下文中的标识某个推送。

push ID空间从零开始，上限是MAX_PUSH_ID帧通告的值。特别是，在客户端发送MAX_PUSH_ID帧之前，服务端无法进行。客户端使用MAX_PUSH_ID帧来控制服务端允许的推送次数。服务端应该（**SHOULD**）从零开始按序使用push ID。客户端在没有发送MAX_PUSH_ID帧而收到推送或流引用超过上限的push ID时，必须（**MUST**）视为H3_ID_ERROR类型的连接错误。

push ID在携带了包含控制数据和头字段的一个或多个PUSH_PROMISE帧的请求消息中使用。这些帧在生成推送的请求流上发送。这使得服务端推送与客户端请求相关联。在多个请求流上承诺相同的push ID时，解压后的请求字段部分必须（**MUST**）以相同的顺序包含相同的字段，并且每个字段中的名称和值都必须（**MUST**）相同。

包含在推送流中的push ID最终实现了这些承诺。推送流标识其实现承诺的push ID，然后包含对承诺请求的响应，如第4.1节所述。

最后，可以在CANCEL_PUSH中包含push ID帧，如第7.2.3节所述。客户端发送此帧表示他们不希望收到承诺的资源。服务端使用这个帧来表明他们不会履行之前的承诺。

并非所有请求都可以推送。服务端可以（**MAY**）推送具有如下属性的请求：

* 可缓存的；请参阅[[HTTP]](#http)的第9.2.3节
* 安全的；请参阅[[HTTP]](#http)的第9.2.1节
* 不包含请求内容或尾部段
  
服务端必须（**MUST**）在:authority伪标头字段中包含一个服务端对其具有权威的值。如果客户端尚未验证推送请求所指示的源的连接，它必须（**MUST**）执行与此连接上，往该源发送请求之前相同的验证过程；见第3.3节。如果此验证失败，则客户端不得（**MUST NOT**）认为服务端对该源具有权威性。

客户端应在收到包含不可缓存、不安全、存在请求内容或认为服务端不具有权威性的请求的 PUSH_PROMISE帧后发送CANCEL_PUSH帧。不得（**MUST NOT**）使用或缓存任何相应的响应。

每个推送响应都与一个或多个客户端请求相关联。此推送与收到PUSH_PROMISE帧的请求流相关联。在多个请求流上发送具有相同push ID的PUSH_PROMISE帧，可以将此服务端推送与其他客户端请求相关联。这些关联不会影响协议的操作，但用户代理在决定如何使用推送资源时可以（**MAY**）参考这些关联。

PUSH_PROMISE帧的顺序相对于某些部分的响应很重要。服务端应该（**SHOULD**）在HEADERS和DATA帧之前发送PUSH_PROMISE帧。这减少了客户端请求即将由服务端推送的资源的机会。

因为乱序，推送的数据可能在相应的PUSH_PROMISE帧之前到达。当客户端收到新的推送流时如果push ID未知，则关联的客户端请求和推送的请求标头字段都是未知的。客户端可以缓存流数据以期待匹配的PUSH_PROMISE帧. 客户端可以使用流控（[[QUIC-TRANSPORT]](#quic)第4.1节）来限制服务端可能提交给推送流的数据量。如果在合理的时间内，没有收到对应的PUSH_PROMISE帧，客户端应该（**SHOULD**）中止读取并丢弃已经从推送流中读取的数据。

推送的流数据也可以在客户端取消推送后到达。在这种情况下，客户端可用H3_REQUEST_CANCELLED错误码中止读取流。这要求服务端不要传输额外的数据，并表明它将在收到时丢弃。

如果客户端实现了HTTP缓存，则可缓存的推送响应（参见[[HTTP-CACHING]](#http-caching)的第3章）可以被客户端存储。在接收到推送的响应时，应该（**SHOULD**）被认为已在源服务端上成功验证（例如，存在“no-cache”缓存响应指令时；参见[[HTTP-CACHING]](#http-caching)第5.2.2.4节）。

不可缓存的推送响应不得（**MUST NOT**）由任何HTTP缓存存储。它们可以（**MAY**）单独提供给上层应用。


# 5. Connection Closure

一旦建立，HTTP/3 连接就可以持续用于收发请求和响应，直到连接关闭。连接关闭可以有多种方式。

## 5.1 Idle Connections

每个QUIC终端在握手期间声明一个空闲超时时间。如果QUIC连接持续空闲（没有收到数据包）超过此时间，则对端将假定连接已关闭。如果现有连接的空闲时间超过了QUIC握手期间协商的空闲超时时间，HTTP/3实现将需要为新请求打开一个新的HTTP/3连接，如果接近空闲超时时间，他们也应该（**SHOULD**）这样做；请参阅[[QUIC-TRANSPORT]](#quic)的第10.1节。

如[[QUIC-TRANSPORT]](#quic)的第10.1.2节所述，当请求或服务端推送有未完成的响应时，HTTP客户端应要求传输保持连接打开状态。如果客户端不期待来自服务端的响应了，则允许空闲连接自然超时比花费精力维护可能不需要的连接更可取。网关可以（**MAY**）根据需要保持连接，权衡考虑与服务端建立连接的时延成本。服务端不应（**SHOULD NOT**）主动保持连接打开状态。

## 5.2. Connection Shutdown

即使连接非空闲，任一终端都可以决定停止使用该连接，并启动一个正常的连接关闭。终端通过发送GOAWAY帧启动HTTP/3连接的正常关闭。GOAWAY帧包含一个ID，该ID向接收方指示在此连接中，已处理或可能处理的请求或推送的范围。服务端在此帧中包含客户端发起的双向流的流ID，客户端在此帧中包含push ID。GOAWAY帧的发送方会拒绝比此帧中ID更大的ID的请求或推送（第4.1.1节）。如果没有处理请求或推送，则此ID可能（**MAY**）为零。

GOAWAY帧携带的信息使得客户端和服务端能够在关闭HTTP/3连接之前，就接受哪些请求或推送达成一致。在发送GOAWAY帧时，终端应该（**SHOULD**）显式取消（参见第4.1.1和7.2.3节）任何ID大于或等于所指示的ID的请求或推送，以便清除受影响流的传输状态。后续更多请求或推送到达，终端也应该（**SHOULD**）继续照此处理。

终端在收到对端GOAWAY帧后，不得（**MUST NOT**）在此连接上发起新请求或推送新Promise。客户端可以（**MAY**）发起一个新连接来发送其他请求。

一些请求或推送可能已经在传输中：

* 收到GOAWAY帧时，如果客户端已经发送了流ID大于或等于GOAWAY帧中ID的请求，这些请求将不会被处理。客户端可以在不同的HTTP连接上安全地重试未被处理的请求。当服务端关闭连接时，无法重试请求的客户端会丢失所有在途的请求。

    来自服务端的，流ID小于GOAWAY帧中流ID的请求可能已被处理，在如下情况下才能确定这些请求的状态：收到响应；流被单独重置；收到另一个GOAWAY帧，其流ID小于当前请求的流ID；连接终止。

    如果未处理这些请求，服务端可以（**MAY**）会拒绝小于指定ID的流上的单独请求。

* 如果服务端收到GOAWAY帧，那么此前发出的push ID大于或等于此帧中ID的推送，可能都不会被客户端接受。
  
在知道连接即将关闭时，服务端应该（**SHOULD**）提前发送一个GOAWAY帧通知对端，即使提前量很小，以便对端可以知道请求是否已被部分处理。例如，如果HTTP客户端在服务端关闭QUIC连接的同时，发送了POST请求，如果服务端不发送GOAWAY帧来指示它可能已经处理的流，客户端将无法知道服务端是否已经开始处理该POST请求。

一个终端可以（**MAY**）发送多个带有不同ID的GOAWAY帧，但每个帧中的ID不得（**MUST NOT**）大于任何先前GOAWAY帧中的ID，因为客户端可能已经在另一个HTTP连接上重试了未处理的请求。收到比之前GOAWAY帧中的更大的ID必须（**MUST**）视为H3_ID_ERROR类型的连接错误。

尝试正常关闭连接的终端可以发送GOAWAY帧，将ID值设置为最大可选值（服务端为2<sup>62</sup>-4，客户端为2<sup>62</sup>-1）。对端收到此帧后会停止创建新请求或推送。在途的请求或推送到达之后，终端可以发出另一个GOAWAY帧，指示在连接结束之前它可以接受的请求或推送。这保证可以优雅关闭连接而不丢失请求。

客户端对它发送的GOAWAY帧中的Push ID字段的取值方面具有更大的灵活性。值2<sup>62</sup>-1表示服务端可以继续完成已经承诺的推送。较小的值表示客户端将拒绝push ID大于或等于该值的推送。和服务端一样，客户端可以（**MAY**）继续发送GOAWAY帧，只要其携带的push ID不大于任何先前发送的值。

即使已经用GOAWAY帧表示给定的请求或推送在收到时也不会被处理或接受，底层传输资源仍然存在。发起这些请求的终端可以关闭它们以清除传输状态。

一旦处理完所有接收到的请求和推送，终端就可以将连接变为空闲状态，或者可以（**MAY**）启动连接的立即关闭。完成优雅关闭的终端应该（**SHOULD**）使用H3_NO_ERROR码关闭连接。

如果客户端的请求耗尽了所有可用的双向流ID，则服务端无需发送GOAWAY帧，因为客户端无法发出更多请求了。

## 5.3 Immediate Application Closure

HTTP/3实现可以随时以这种方式立即关闭QUIC连接：向对端发送QUIC CONNECTION_CLOSE帧，指示应用层已终止连接。此帧中的应用层错误码可以向对端指示关闭连接的原因。有关在HTTP/3中关闭连接时可以使用的错误码，请参阅第8章。

在关闭连接之前发送GOAWAY帧可以（**MAY**）允许客户端重试某些请求。将GOAWAY帧与QUIC CONNECTION_CLOSE帧放在同一数据包中发送可以提高客户端接收该帧的机会。

如果存在未显式关闭的流，则在关闭连接时会将其隐式关闭；请参阅[[QUIC-TRANSPORT]](#quic)的第10.2节。

## 5.4 Transport Closure

由于各种原因，QUIC传输可能会向应用层指示连接已终止。这可能是由于对端的显式关闭、传输级错误或中断，连接的网络拓扑更改导致的。

如果连接在没有GOAWAY帧的情况下终止，客户端必须（**MUST**）假设任何发送的请求，无论是全部还是部分，都可能已被处理。

# 6. Stream Mapping and Usage

QUIC在每个流上都提供可靠的、按序的字节传输，但不保证与其他流上的字节按序投递。在QUIC版本1中，包含HTTP帧的流数据由QUIC STREAM帧承载，但这种帧在HTTP层是不可见的。传输层对接收到的流数据进行缓冲和排序，向应用层投递可靠的字节流。尽管QUIC允许在流上进行不保序投递，但HTTP/3并未使用此功能。

QUIC流可以是单向的，仅从发送方到接收方单向传输数据，也可以是双向的，两个方向都可传输数据。流可以由客户端或服务端发起。有关QUIC流的更多详细信息，请参阅[[QUIC-TRANSPORT]](#quic)的第2章。

当通过QUIC发送HTTP字段和数据时，QUIC层处理大部分流管理功能。使用QUIC时，HTTP不需要进行任何单独的多路复用：通过QUIC流发送的数据总是映射到特定的HTTP事务或整个HTTP/3连接上下文。

## 6.1 Bidirectional Streams

所有客户端发起的双向流都用于HTTP请求和响应。双向流的设计确保响应可以很容易地与请求相关联。这些流称为请求流。

这意味着客户端的第一个请求在流ID为0的流上发送，随后的请求在流ID 4、8上发送，依此类推。为了这些流可以正常打开，HTTP/3服务端应该（**SHOULD**）为其允许接入的流的个数和初始流控窗口配置非零的最小值。为了避免不必要地限制并发数，一次至少应该（**SHOULD**）允许100个请求流。

HTTP/3不使用由服务端启动的双向流，不过允许扩展定义这类流的用途。客户端必须（**MUST**）将收到服务端发起的双向流视为H3_STREAM_CREATION_ERROR类型的连接错误，除非已协商此类扩展用途。

## 6.2 Unidirectional Streams

在任一方向上的单向流用于多种目的。其目的由流类型指示，在流的开头作为可变长度整数发送。此整数之后的数据格式和结构由流类型决定：

```
   Unidirectional Stream Header {
     Stream Type (i),
   }

                   Figure 1: Unidirectional Stream Header
```

本文中定义了两种流类型：控制流（第6.2.1节）和推送流（第6.2.2节）。[[QPACK]](#qpack)定义了两种额外的流类型。其他流类型可以通过对HTTP/3的扩展来定义；有关详细信息，请参阅第9章。某些流类型保留以备后用（第6.2.3节）。

HTTP/3连接在其生命周期的早期阶段的性能，对单向流上数据的创建和交换很敏感。终端过度限制流的个数或这些流的流控窗口，将增加对端提前达到限制并被阻塞的机会。特别是，实现应该考虑对端可能希望使用一些合法的单向流，执行保留的流行为（第6.2.3节）。

每个终端需要为HTTP控制流创建至少一个单向流。QPACK需要两个额外的单向流，而其他扩展可能需要更多的流。因此，客户端和服务端协商的传输参数必须（**MUST**）允许对端创建至少三个单向流。这些传输参数还应该（**SHOULD**）为每个单向流提供至少1,024字节的流控credit。

请注意，如果终端在创建关键单向流之前耗尽了所有初始credit，则不需要授予额外credit来创建更多单向流。终端应该（**SHOULD**）创建HTTP控制流以及必选扩展所需的单向流（例如QPACK编码器和解码器流），然后在其对端允许的情况下创建其他流。

如果Stream Type指示的是接收方不支持的流类型，则流的其余部分也无法处理，因为语义未知。收到未知流类型的终端必须（**MUST**）中止读取流或丢弃传入数据，而不执行进一步处理。如果读取被中止，接收方应该（**SHOULD**）使用H3_STREAM_CREATION_ERROR类型的错误码或保留的错误码（第8.1节）。接收方不得（**MUST NOT**）将未知流类型视为连接错误。

由于某些流类型会影响连接状态，因此接收方不应（**SHOULD NOT**）在未读取流类型之前丢弃来自传入单向流的数据。

实现可以（**MAY**）在不知对端是否支持某种流类型的情况下发送此类型数据。但是，针对某种流类型，可以修改现有协议组件（包括QPACK或其他扩展）的状态或语义，要求在未知对端是否支持的情况下，不得（**MUST NOT**）发送此类型数据。

除非另有说明，否则发送方可以关闭或重置单向流。接收方必须（**MUST**）容忍在收到单向流标头之前此流就已经被关闭或重置了。

### 6.2.1 Control Streams

流类型0x00表示控制流。此流上的数据由第7.2节中定义的HTTP/3帧构成。

每一终端都必须（**MUST**）在连接开始时，启动一个控制流，并发送SETTINGS帧作为此流上的第一帧。如果控制流的第一帧是其他帧类型，则必须（**MUST**）将其视为H3_MISSING_SETTINGS类型的连接错误。每个终端只允许发起一个控制流，收到声明是控制流的第二个流必须（**MUST**）被视为H3_STREAM_CREATION_ERROR类型的连接错误。发送方不得（**MUST NOT**）关闭控制流，接收方不得（**MUST NOT**）要求发送方关闭控制流。如果任一控制流在任意时间关闭，则必须（**MUST**）都将其视为H3_CLOSED_CRITICAL_STREAM类型的连接错误。连接错误在第8章中描述。

因为控制流的内容是用于管理其他流的行为，终端应该（**SHOULD**）提供足够的流控credit来防止终端的控制流被阻塞。

使用一对单向流而不是单个双向流的设计，允许任一对端尽快发送数据。如果QUIC连接上的0-RTT可用，客户端或服务端可以提前发送流数据。

### 6.2.2 Push Streams

服务端推送是HTTP/2中引入的一个可选功能，它允许服务端在客户端发出请求之前发送响应。有关详细信息，请参阅第4.6节。

流类型0x01表示推送流，后跟它承诺的推送的ID，编码为可变长度整数。此流上的其余数据由第7.2节中定义的HTTP/3帧组成，并通过零个或多个中间HTTP响应、后跟一个最终HTTP响应来满足承诺的服务端推送，如第4.1节中定义。服务端推送和push ID在4.6节中描述。

只有服务端可以推送；如果服务端收到客户端发起的推送流，则必须（**MUST**）将其视为H3_STREAM_CREATION_ERROR类型的连接错误。

```
   Push Stream Header {
     Stream Type (i) = 0x01,
     Push ID (i),
   }

                        Figure 2: Push Stream Header
```

客户端应该（**SHOULD**）在读取推送流标头之后再确定是否终止读取后续数据，不然可能导致客户端和服务端对已使用的push ID出现分歧。

每个push ID必须（**MUST**）只能在推送流标头中使用一次。如果客户端检测到推送流标头包含的push ID在另一个推送流标头中使用过，客户端必须（**MUST**）将此视为H3_ID_ERROR类型的连接错误。

### 6.2.3 Reserved Stream Types

形如 0x1f*N+0x21（N为非负整数）的保留流类型用来测试是否未知流类型会被终端忽略。这些流没有语义，可以在需要应用层填充时发送。它们也可以（**MAY**）在当前没有数据传输的连接上发送。终端在收到时不得（**MUST NOT**）认为这些流具有任何意义。

未知类型流的有效负载和长度随便发送方怎么填。当收到保留的流类型时，实现可以（**MAY**）干脆地终止流或重置它。重置流时，应该（**SHOULD**）使用H3_NO_ERROR类型的错误码或其他保留的错误码（第8.1节）。

# 7. HTTP Framing Layer

HTTP帧在QUIC流上承载，如第6章所述。HTTP/3定义了三种流类型：控制流、请求流、推送流。本节介绍HTTP/3帧格式及其允许的流类型；概览见表1。附录A.2中给出了HTTP/2和HTTP/3帧之间的比较。


Table 1: HTTP/3 Frames and Stream Type Overview
| Frame | Control Stream | Request Stream | Push Stream | Section |
|:---|:---|:---|:---|:---|
| DATA | No | Yes | Yes | Section 7.2.1 |
| HEADERS | No | Yes | Yes | Section 7.2.2 |
| CANCEL_PUSH | Yes | No | No | Section 7.2.3 |
| SETTINGS | Yes (1) | No | No | Section 7.2.4 |
| PUSH_PROMISE | No | Yes | No | Section 7.2.5 |
| GOAWAY | Yes | No | No | Section 7.2.6 |
| MAX_PUSH_ID | Yes | No | No | Section 7.2.7 |
| Reserved | Yes | Yes | Yes | Section 7.2.8 |


SETTINGS 帧只能作为控制流的第一帧出现；这在表1中用(1)表示。具体指导见相关章节。

请注意，与QUIC帧不同，HTTP/3帧可以跨越多个QUIC数据包。

## 7.1. Frame Layout

HTTP/3帧格式如下：

```
   HTTP/3 Frame Format {
     Type (i),
     Length (i),
     Frame Payload (..),
   }

                       Figure 3: HTTP/3 Frame Format
```

每个帧都包括以下字段：

Type 类型：
标识帧类型的可变长度整数。

Length 长度：
可变长度整数，用于描述帧有效负载的长度（以字节为单位）。

Frame Payload 帧载荷：
有效负载，其语义由Type字段确定。

每个帧的有效负载必须（**MUST**）准确包含在其帧结构中标识的字段。在已标识字段之后还包含额外字节或中途被截断的帧都必须（**MUST**）被视为H3_FRAME_ERROR类型的连接错误。特别是，帧中有多重长度编码的话必须（**MUST**）是自洽的；见第10.8节。

当流被突然终止时，如果流上的最后一帧被截断，则必须（**MUST**）将其视为H3_FRAME_ERROR类型的连接错误。突然终止的流可能会在帧中的任意位置重置。

## 7.2. Frame Definitions

### 7.2.1. DATA

DATA帧（type=0x00）承载与HTTP请求或响应内容相关的任意可变长度字节序列。

DATA帧必须（**MUST**）与HTTP请求或响应相关联。如果在控制流上接收到DATA帧，接收方必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误。

```
   DATA Frame {
     Type (i) = 0x0,
     Length (i),
     Data (..),
   }

                            Figure 4: DATA Frame
```

### 7.2.2 HEADERS

HEADERS帧（type=0x01）用于携带使用QPACK编码的HTTP字段部分。有关详细信息，请参阅[[QPACK]](#qpack)。

```
   HEADERS Frame {
     Type (i) = 0x1,
     Length (i),
     Encoded Field Section (..),
   }

                          Figure 5: HEADERS Frame
```

HEADERS帧只能在请求流上或推送流发送。如果在控制流上接收到HEADERS帧，接收方必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误。

### 7.2.3. CANCEL_PUSH

CANCEL_PUSH帧（type=0x03）用于在推送流被接收之前，要求取消服务端推送。CANCEL_PUSH帧通过push ID标识服务端推送（参见第4.6节），push ID编码为可变长度整数。

客户端发送CANCEL_PUSH帧即表明它不希望接收承诺的资源。服务端应该（**SHOULD**）中止发送资源，但其处理机制取决于相应的推送流的状态。如果此时还没有创建该推送流，则不继续创建；如果推送流已经打开，则应该（**SHOULD**）立即终止该流；如果推送流已经结束，服务端可以（**MAY**）立即终止流或不采取任何动作。

服务端发送CANCEL_PUSH帧即表明它不会履行之前发送的承诺。客户端不能期望服务端继续履行承诺，除非它已经收齐并处理了承诺的响应。不管推送流是否已被打开，服务端应该（**SHOULD**）在它确定不能继续时发送CANCEL_PUSH帧。如果流已被打开，服务端可以中止在流上发送，错误码为H3_REQUEST_CANCELLED。

发送CANCEL_PUSH帧对现有推送流的状态没有直接影响。当客户端已经接收到相应的推送流时，它不应（**SHOULD NOT**）发送CANCEL_PUSH帧。推送流可能在客户端发送CANCEL_PUSH帧之后到达，因为服务端可能尚未处理CANCEL_PUSH帧。客户端应该（**SHOULD**）中止读取流，错误码为H3_REQUEST_CANCELLED。

在控制流上发送CANCEL_PUSH帧、在控制流以外的流上接收到CANCEL_PUSH帧必须（**MUST**）被视为H3_FRAME_UNEXPECTED类型的连接错误。

```
   CANCEL_PUSH Frame {
     Type (i) = 0x3,
     Length (i),
     Push ID (i),
   }

                        Figure 6: CANCEL_PUSH Frame
```

CANCEL_PUSH帧带有编码为可变长度整数的push ID。Push ID字段标识正在被取消的服务端推送流；见第4.6节。如果收到CANCEL_PUSH帧中的push ID大于当前连接容许的值，则必须（**MUST**）被视为H3_ID_ERROR类型的连接错误。

如果客户端收到一个CANCEL_PUSH帧，由于乱序的关系，该帧中的push ID可能尚未被其他PUSH_PROMISE帧提及。如果服务端收到的CANCEL_PUSH帧中的push ID未被任意PUSH_PROMISE帧提到，这必须（**MUST**）视为H3_ID_ERROR类型的连接错误。

### 7.2.4. SETTINGS

SETTINGS帧（type=0x04）承载影响终端通信方式的配置参数，例如终端行为的首选项和限制。单独地，一个SETTINGS参数也可以称为“setting”；每个设置参数的标识和值可以称为“setting标识”和“setting值”。

SETTINGS帧适用于整个HTTP/3连接，而不是单个流。SETTINGS帧必须（**MUST**）作为每个终端控制流的第一帧发送（见第6.2.1节），并且随后不得（**MUST NOT**）再发。如果终端在控制流上接收到第二个SETTINGS帧，必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误。

SETTINGS帧不得（**MUST NOT**）在控制流以外的任何流上发送.如果终端在不同的流上接收到SETTINGS帧，终端必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误。

SETTINGS参数不经过协商，它们定义了接收端可以使用的，发送端的特性。不过，SETTINGS的使用暗涵协商：每个终端都使用SETTINGS帧来通告一组其支持的值。setting的定义可以得出使用这两个集合中的哪个选项的结论。SETTINGS不提供明确选项何时生效的机制。

每个终端可以通告相同参数的不同值。例如，客户端可能愿意使用非常大的响应字段部分，而服务端对请求长度更加谨慎。

相同的setting标识不得（**MUST NOT**）在SETTINGS帧中出现多次。接收方可以（**MAY**）将setting标识重复视为H3_SETTINGS_ERROR类型的连接错误。

SETTINGS帧的有效载荷由零个或多个参数组成。每个参数由一个setting标识和一个setting值组成，两者都编码为QUIC可变长度整数。

```
   Setting {
     Identifier (i),
     Value (i),
   }

   SETTINGS Frame {
     Type (i) = 0x4,
     Length (i),
     Setting (..) ...,
   }

                          Figure 7: SETTINGS Frame
```

实现必须（**MUST**）忽略任何带有它不理解的setting标识的参数。

#### 7.2.4.1. Defined SETTINGS Parameters

HTTP/3中定义了以下setting：

SETTINGS_MAX_FIELD_SECTION_SIZE（0x06）：默认值为无限制。用法见第4.2.2节。

形如 0x1f*N+0x21（N为非负整数）格式的setting标识，是为了满足忽略未知标识符的要求而保留的。此类setting没有明确的含义。终端应该（**SHOULD**）在它们的SETTINGS帧中至少包含一个这样的setting。终端在收到时不得（**MUST NOT**）认为此类setting具有任何意义。

因为此类setting没有确定含义，所以其值可由实现任意选择。

在[[HTTP/2]](#http2)中定义的，HTTP/3中没有对应setting的标识也被保留（第11.2.2节）。不得（**MUST NOT**）发送这些保留的setting，收到的话必须（**MUST**）视为H3_SETTINGS_ERROR类型的连接错误。

其他setting可以通过HTTP/3扩展来定义；有关详细信息，请参阅第9章。

#### 7.2.4.2 Initialization

HTTP实现不得（**MUST NOT**）发送基于其当前终端setting，理解为无效的帧或请求。

所有setting都有初始值。因为携带setting的数据包可能会丢失或延迟，每个终端在对端的SETTINGS帧到达之前发送消息时都应该（**SHOULD**）使用初始值。当SETTINGS帧到达时，所有setting都更新为新值。

这消除了在发送消息之前等待SETTINGS帧的需要。终端在发送SETTINGS帧之前不得（**MUST NOT**）要求从对端收到任何数据；必须（**MUST**）在传输准备好发送数据后立即发送setting。

对于服务端，每个客户端setting的初始值都是默认值。

对于使用1-RTT QUIC连接的客户端，每个服务端setting的初始值都是默认值。在QUIC处理包含SETTINGS的数据包之前，1-RTT密钥就是可用状态了，即使服务端立即发送SETTINGS也是如此。客户端不应（**SHOULD NOT**）在发送请求之前无限期地等待SETTINGS帧到达，但他们应该（**SHOULD**）处理接收到的数据报文，以增加在发送第一个请求之前处理SETTINGS帧的可能性。

当使用0-RTT QUIC连接时，每个服务端setting的初始值是前一次会话中使用的值。客户端应该（**SHOULD**）保存服务端在HTTP/3连接中提供的与会话恢复有关的setting，但他们可以（**MAY**）选择在某些情况下不存储setting（例如，如果在SETTINGS帧之前收到会话凭证）。客户端在尝试0-RTT时必须（**MUST**）使用存储的setting——如果没有存储值，则为默认值。一旦服务端给出了新setting，客户端必须（**MUST**）使用这些值。

服务端可以（**MAY**）记住它公布的setting或存储的会话凭证的完整性保护副本，并在收到0-RTT数据时恢复信息。服务端使用HTTP/3 setting值来确定是否接受0-RTT数据。如果服务端无法确定客户端保存的setting与其当前setting是否兼容，则它不得（**MUST NOT**）接受0-RTT数据。客户端保存的setting是兼容的，如果这些setting不会违反服务端的当前setting。

服务端可以接受0-RTT，并随后在其SETTINGS帧中提供不同的setting。如果服务端接受0-RTT数据，则服务端不得（**MUST NOT**）在其SETTINGS帧中减少任何限制，或更改为与客户端使用0-RTT数据不兼容的任何值。服务端必须（**MUST**）包含与其默认值不同的所有setting。如果服务端接受0-RTT但随后发送的setting与先前指定的setting不兼容，则必须（**MUST**）将其视为H3_SETTINGS_ERROR类型的连接错误。如果服务端接受0-RTT但随后发送的SETTINGS帧，未携带被客户端认为是具有非默认值的setting（不同于保留的setting标识），则必须（**MUST**）将其视为H3_SETTINGS_ERROR类型的连接错误。

### 7.2.5 PUSH_PROMISE

PUSH_PROMISE帧（type=0x05）用于在请求流上承载服务端承诺的，发往客户端的请求头部段。

```
   PUSH_PROMISE Frame {
     Type (i) = 0x5,
     Length (i),
     Push ID (i),
     Encoded Field Section (..),
   }

                        Figure 8: PUSH_PROMISE Frame
```

有效载荷包括：

Push ID 推送ID：
标识服务端推送操作的可变长度整数。push ID用于推送流标头（第4.6节）和CANCEL_PUSH帧。

Encoded Field Section 编码字段部分：
承诺响应的，QPACK编码的请求头字段。有关详细信息，请参阅[[QPACK]](#qpack)。

服务端不得（**MUST NOT**）使用大于客户端在MAX_PUSH_ID帧中给出的push ID（第7.2.7节）。客户端收到违反此约定的PUSH_PROMISE帧必须（**MUST**）视为H3_ID_ERROR类型的连接错误。

服务端在多个PUSH_PROMISE帧中可以（**MAY**）使用相同的push ID。这种情况下，解压缩后的请求，其头部集合必须（**MUST**）以相同顺序排列相同字段，并且每个字段中的名称和值都必须（**MUST**）完全匹配。客户端应该（**SHOULD**）多次比较承诺资源的请求头部段。如果客户端收到的push ID已经承诺过，但检测到头部段不匹配，则必须（**MUST**）视为H3_GENERAL_PROTOCOL_ERROR类型的连接错误。如果解压缩的字段部分完全匹配，客户端应该（**SHOULD**）将推送的内容与接收到PUSH_PROMISE帧的每个流相关联。

允许对同一个push ID的重复引用主要是为了减少并发请求造成的重复。服务端在很长一段时间内应该（**SHOULD**）避免重用push ID。客户端可能会使用服务端推送响应，而不会保留这些响应以供长期重用。客户端收到PUSH_PROMISE帧，包含之前已经使用和忽略的push ID的话，将被迫忽略此承诺。

如果在控制流上收到PUSH_PROMISE帧，客户端必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误。

客户端不得（**MUST NOT**）发送PUSH_PROMISE帧。服务端必须（**MUST**）将收到PUSH_PROMISE帧视为H3_FRAME_UNEXPECTED类型的连接错误。

有关服务端推送机制的完整描述，请参见第4.6节。

### 7.2.6. GOAWAY

GOAWAY帧（type=0x07）用于启动任一终端的HTTP/3连接的正常关闭。GOAWAY允许终端停止接受新请求或推送，同时仍完成对先前接收到的请求和推送的处理。这将启动管理操作，例如服务端维护。GOAWAY本身不会关闭连接。

```
   GOAWAY Frame {
     Type (i) = 0x7,
     Length (i),
     Stream ID/Push ID (..),
   }

                           Figure 9: GOAWAY Frame
```

GOAWAY帧总是在控制流上发送。在服务端到客户端方向上，它携带客户端发起的QUIC双向流的流ID，编码为可变长度整数。客户端收到GOAWAY帧的流ID为其他类型的话，必须（**MUST**）视为H3_ID_ERROR类型的连接错误。

在客户端到服务端的方向上，GOAWAY帧携带一个push ID，编码为可变长度整数。

GOAWAY帧适用于整个连接，而不是特定的流。客户端在控制流以外的流上收到GOAWAY帧必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误。

有关GOAWAY帧用法的更多信息，请参见第5.2节。

### 7.2.7 MAX_PUSH_ID

客户端使用MAX_PUSH_ID帧（type=0x0d）来控制服务端可以发起的服务端推送次数。这将设置服务端可以在PUSH_PROMISE帧和CANCEL_PUSH帧中使用的push ID的最大值。因此，除了QUIC传输维护的限制之外，这也限制了服务端可以发起的推送流的数量。

MAX_PUSH_ID帧总是在控制流上发送。在任何其他流上收到MAX_PUSH_ID帧必须（**MUST**）被视为H3_FRAME_UNEXPECTED类型的连接错误。

服务端不得（**MUST NOT**）发送MAX_PUSH_ID帧。客户端必须（**MUST**）将收到MAX_PUSH_ID帧视为H3_FRAME_UNEXPECTED类型的连接错误。

最大push ID在创建HTTP/3连接时是未设置的，这意味着服务端在收到MAX_PUSH_ID帧之前无法进行推送。客户端希望管理服务端推送承诺次数的话，可以发送MAX_PUSH_ID帧增大最大push ID值，使得服务端履行或取消推送。

```
   MAX_PUSH_ID Frame {
     Type (i) = 0xd,
     Length (i),
     Push ID (i),
   }

                        Figure 10: MAX_PUSH_ID Frame
```


MAX_PUSH_ID帧携带一个可变长度整数，用于标识服务端可以使用的push ID的最大值；见第4.6节。MAX_PUSH_ID帧不能减少最大push ID的值。收到该值小于之前MAX_PUSH_ID帧通告的最大push ID值的帧，必须（**MUST**）视为H3_ID_ERROR类型的连接错误。

### 7.2.8 Reserved Frame Types

形如 0x1f*N+0x21（N为非负整数）格式的帧类型，以测试是否忽略未知类型的要求（第9章）。这些帧没有语义，它们可以（**MAY**）在允许发送帧的任何流上发送。这使得它们能够用于应用层填充。终端在收到这些帧时不得（**MUST NOT**）认为这些帧具有任何意义。

帧的有效负载和长度由实现自行指定。

在HTTP/2中使用，但在HTTP/3没有对应的帧类型也被保留（第11.2.1节）。但不得（**MUST NOT**）发送这些帧类型，收到的话必须（**MUST**）视为H3_FRAME_UNEXPECTED类型的连接错误。

# 8. Error Handling

当流无法成功结束时，QUIC允许应用层突然终止（重置）该流并给出原因；请参阅[[QUIC-TRANSPORT]](#quic)的第2.4节。这被称为“流错误”。HTTP/3实现可以决定是否关闭QUIC流并给出错误类型。错误码表在第8.1节中定义。流错误码不同于指示错误情况的HTTP状态码。流错误码表示发送方没有传输或消费完整的请求或响应，而HTTP状态码表明成功接收到的请求的处理结果。

如果需要终止整个连接，QUIC类似地提供了给出错误原因的机制；请参阅[[QUIC-TRANSPORT]](#quic)的第5.3节。这被称为“连接错误”。与流错误类似，HTTP/3实现可以终止QUIC连接并使用第8.1节中的错误码给出原因。

尽管关闭流和连接的原因称为“错误码”，但这些操作并不一定表明连接或任一实现存在问题。例如，如果不再需要请求的资源，则可以重置流。

在某些情况下，终端可以（**MAY**）选择将流错误视为连接错误，关闭整个连接以响应单个流上的问题。在做出此选择之前，实现需要考虑对未完成请求的影响。

因为可以在没有协商的情况下定义新的错误码（参见第9章），所以在非预期的上下文中收到错误码或收到未知错误码，必须（**MUST**）被视为等同于H3_NO_ERROR。但是，无论错误码是什么，关闭流都会产生其他影响；参见第4.1节的例子。

## 8.1. HTTP/3 Error Codes

以下错误码定义为在突然终止流、中止读取流或立即关闭HTTP/3连接时使用：

H3_NO_ERROR（0x0100）: 没有错误。当需要关闭连接或流，但发出信号时没有错误时，使用此选项。

H3_GENERAL_PROTOCOL_ERROR（0x0101）: 某种形式上，对端违反了协议，但又没有对应更具体的错误码，或者终端不愿意使用更具体的错误码。

H3_INTERNAL_ERROR（0x0102）: HTTP协议栈发生了一个内部错误。

H3_STREAM_CREATION_ERROR（0x0103）: 终端发现其对端创建了一个它不能接受的流。

H3_CLOSED_CRITICAL_STREAM（0x0104）: HTTP/3连接要求的流被关闭或者重置了。

H3_FRAME_UNEXPECTED（0x0105）: 在当前状态或者当前流上，收到了一个不允许的帧。

H3_FRAME_ERROR（0x0106）: 收到的帧格式不对，或者大小不对。

H3_EXCESSIVE_LOAD（0x0107）: 终端检测到其对端显示出可能产生过量负载的行为。

H3_ID_ERROR（0x0108）: 错误使用流ID或Push ID，比如超过了限制，减小了限制，或者重用。

H3_SETTINGS_ERROR（0x0109）: 终端在SETTNGS帧的载荷中检测到了错误。

H3_MISSING_SETTINGS（0x010a）: 控制流的第一帧不是SETTING帧。

H3_REQUEST_REJECTED（0x010b）: 服务端拒绝了请求，并不会交由应用层处理。

H3_REQUEST_CANCELLED（0x010c）: 请求或它的响应（包括推送的响应）被取消。

H3_REQUEST_INCOMPLETE（0x010d）: 客户端请求不完整，流被终止。

H3_MESSAGE_ERROR（0x010e）: HTTP消息格式错误，无法处理。

H3_CONNECT_ERROR（0x010f）: 响应CONNECT请求而建立的TCP连接被重置或突然地关闭了。

H3_VERSION_FALLBACK（0x0110）: 无法在HTTP/3上为请求提供服务，对端应当在HTTP/1.1上重试。

形如 0x1f*N+0x21（N为非负整数）格式的错误码，测试对端是否履行将未知错误码视为等同于H3_NO_ERROR的要求（第9章）。实现应该（**SHOULD**）在发送H3_NO_ERROR时，以一定概率从此格式集中选择一个错误码发送。

# 9. Extensions to HTTP/3

HTTP/3允许扩展协议。在本节描述的限制范围内，协议扩展可用于提供附加服务或更改协议的任何方面。扩展仅在单个HTTP/3连接范围内有效。

这适用于本文中定义的协议元素，不会影响扩展HTTP的现有选项，例如定义新方法、状态码或字段。

允许扩展使用新的帧类型（第7.2节）、新的settings（第7.2.4.1节）、新的错误码（第8章）或新的单向流类型（第6.2节）。为管理这些扩展点在IANA建立了注册表：帧类型（第11.2.1节）、settings（第11.2.2节）、错误码（第11.2.3节）和流类型（第11.2.4节）。

实现必须（**MUST**）忽略所有可扩展协议元素中的未知或不受支持的值。实现必须（**MUST**）丢弃数据或中止对具有未知或不受支持类型的单向流的读取。这意味着这些扩展点中的任何一个都可以被扩展安全地使用，而无需事先安排或协商。但是，如果已知帧类型需要位于特定位置，例如SETTINGS帧作为控制流的第一帧（见第6.2.1节），未知的帧类型不满足该要求，应该（**SHOULD**）被视为错误。

可能会改变现有协议组件语义的扩展必须（**MUST**）在使用之前进行协商。例如，更改HEADERS格式的扩展在对端给出可以接受的肯定信号之前，不能使用该HEADERS格式。修改现有格式以待生效的方式实现比较复杂，因此，为现有协议元素新定义、分配新标识符可能更有效率。

本文没有规定协商使用扩展的具体方法，不过有指出可以使用setting（第7.2.4.1节）达成此目的。如果两端都设置了表示其愿意使用的扩展的值，则可以使用扩展。如果setting用于扩展协商，则必须（**MUST**）以这样一种方式定义默认值，即如果省略该setting，则禁用扩展。


# 10. Security Considerations

HTTP/3的安全注意事项考量应当和HTTP/2 over TLS类似。不过，[[HTTP/2]](#http2)第10章中的许多考虑因素适用于[[QUIC-TRANSPORT]](#quic) ，参见[[QUIC-TRANSPORT]](#quic) 的讨论。

## 10.1. Server Authority

HTTP/3依赖于HTTP的权限定义。[[HTTP]](#http)的第17.1节讨论了建立授权的安全注意事项。

## 10.2. Cross-Protocol Attacks

在TLS和QUIC握手时使用ALPN可以在应用层数据传输之前协商好应用层协议。这种机制可以保证两端使用相同的协议。

这并不能保证免受所有跨协议攻击。[[QUIC-TRANSPORT]](#quic)的第21.5节描述了QUIC数据包的明文可用于对不使用认证传输的终端进行请求伪造一些方法。

## 10.3. Intermediary Encapsulation Attacks

HTTP/3字段编码允许在HTTP使用的语法中表达不是有效字段名的名称（[[HTTP]](#http)的第5.1节）。包含无效字段名的请求或响应必须（**MUST**）被视为格式错误。因此，中间设备无法将包含无效字段名的HTTP/3请求或响应转换为HTTP/1.1消息。

同样，HTTP/3可以传输无效的字段值。虽然大多数可以编码的值不会影响字段解析，但如果逐字翻译，攻击者可能会利用回车符(ASCII 0x0d)、换行符(ASCII 0x0a)和空字符(ASCII 0x00)。任何包含字段值中不允许的字符的请求或响应必须（**MUST**）被视为格式错误。有效字符在[[HTTP]](#http)的第5.5节中的“字段内容”ABNF规则中定义。

## 10.4. Cacheability of Pushed Responses

推送的响应没有来自客户端的明确请求，该请求由服务端在PUSH_PROMISE帧中提供。

根据源服务端在Cache-Control标头字段中的指引，客户端可以缓存推送的响应。但是，如果一台服务器托管多个租户，这可能会出现问题。例如，服务器可能会将其URI空间分散提供给多个租户。

当多个租户在同一台​​服务端上共享空间时，该服务端必须（**MUST**）确保租户无法推送他们无权访问的资源表示。如果不执行此操作，租户将可以从缓存中提取URI表示，从而覆盖已授权租户提供的实际资源。

客户端被要求拒绝非授权源服务端的推送响应；见第4.6节。

## 10.5. Denial-of-Service Considerations

与HTTP/1.1或HTTP/2连接相比，HTTP/3连接可能需要更大的资源投入才能运行。字段压缩和流控的使用需要存储大量状态，因此需要更多资源。这些特性的设置项可确保其内存要求受到严格限制。

PUSH_PROMISE帧的数量以类似的方式受到约束。接受服务端推送的客户端应该（**SHOULD**）限制它一次发布的push ID的数量。

处理能力不能像状态能力那样得到有效保护。

发送要求对端忽略的，未定义的协议元素的能力，可能会被滥用，以导致对端花费额外的处理时间。这可以通过设置多个未定义的SETTINGS参数、未知帧类型或未知流类型来达成目的。但是请注意，某些用途是完全合法的，例如用可选可理解的扩展和填充以增加对流量分析的对抗能力。

压缩字段部分也提供了一些浪费处理资源的机会；有关潜在滥用的更多详细信息，请参阅[[QPACK]](#qpack)的第7章。

所有这些特性——即服务端推送、未知协议元素、字段压缩——都有合法用途。这些功能只有在不必要或过度使用时才会成为负担。

不监视此类行为的终端会将自己暴露在拒绝服务攻击的风险中。实现应该（**SHOULD**）跟踪这些特性的使用并设置它们的使用限制。终端可以（**MAY**）将可疑的活动视为H3_EXCESSIVE_LOAD类型的连接错误，但误报会导致中断有效的连接和请求。

### 10.5.1. Limits on Field Section Size

大的字段部分（第4.1节）可能导致实现提交大量状态。对路由至关重要的标头字段可能出现在标头部分的末尾，这可能阻止标头部段流到达其最终目的地。这种乱序和其他原因（例如缓存校对）意味着终端可能需要缓冲整个标头段。由于字段部分的大小没有硬性限制，一些终端可能被迫为标头字段提交大量可用内存。

终端可以使用SETTINGS_MAX_FIELD_SECTION_SIZE（第4.2.2节）setting，以告知对端可能适用于字段部分大小的限制。此setting只是建议性的，因此终端可以（**MAY**）选择发送超出此限制的字段部分，并有可能被接收端将请求或响应视为格式错误。此setting特定于HTTP/3连接，因此任何请求或响应都可能遇到具有较低或未知限制的下一跳。中间设备可以尝试不同终端提供的值来避免这个问题，但他们不是强制的。

接收到比它愿意处理的更大的字段部分的服务端可以发送HTTP 431（请求标头字段太大）状态码（[[RFC6585]](#rfc6585)）。客户端可以丢弃它无法处理的响应。

### 10.5.2. CONNECT Issues

CONNECT方法可用于在代理上创建不对称的负载，因为与创建和维护TCP连接相比，流创建性价比相对较高。因此，支持CONNECT的代理可能在它接受的并发数量上更加保守。

代理还可能会在关闭携带CONNECT请求的流之后，为TCP连接维护一些资源，因为传出TCP连接仍处于TIME_WAIT状态。考虑到这一点，代理可能会在TCP连接终止后，稍后增大QUIC流限制一段时间。

## 10.6. Use of Compression

当加密数据在与攻击者掌握的数据相同的上下文中被压缩时，攻击者可能可以恢复加密数据。HTTP/3启用字段压缩（第4.2节）；以下担心也适用于HTTP压缩内容编码；请参阅[[HTTP]](#http)的第8.4.1节。

有一些比较常见的利用网络特性的压缩攻击（例如，[[BREACH]](#breach)）。攻击者诱发出多个包含不同明文的请求，观察每个请求中生成的密文的长度，当对秘钥的猜测正确时，会显示较短的长度。

在安全通道上通信的实现，不得（**MUST NOT**）同时压缩包含加密和攻击者掌握的数据的内容，除非每个数据源使用单独的压缩上下文。如果不能可靠地确定数据源，则不得（**MUST NOT**）使用压缩。

[[QPACK]](#qpack)中描述了有关字段部分压缩的进一步考虑。


## 10.7. Padding and Traffic Analysis

填充可用于模糊帧内容的确切长度，减轻HTTP中的特定攻击，例如如上节所述的对压缩内容包括密文数据和攻击者掌握的明文的攻击（例如，[[BREACH]](#breach)）。

HTTP/2使用PADDING帧，和其他帧中的填充字段，以使连接更能抵抗流量分析，而HTTP/3依赖传输层PADDING或使用第7.2.8节和第6.2节中讨论的保留帧和流类型。这些填充方法产生的什么样的结果与如下事项相关：填充的粒度、如何根据受保护的信息进行填充、是否在数据包丢失的情况下应用填充以及实现如何控制填充等方面。

即使连接空闲，保留流类型也可用于流量整形。由于HTTP流量经常以突发的形式出现，因此可以使用明显的流量来掩盖这种突发的时间点或持续时间，甚至使之看起来像是在发送恒定的数据流。但是，由于此类流量仍由接收方进行流控，因此流量耗尽却没有获得足够的流控credit的话可能会限制发送方发送真实流量的能力。

为了减轻基于压缩的攻击，禁用或限制压缩可能比使用填充更可取。

使用填充可能会导致保护效果比看上去明显的要差。冗余填充甚至可能适得其反。充其量，填充只会增加攻击者通过增加观察帧数来推断长度信息的难度。错误实现的填充方案更容易被破解。特别的，具有可预测分布的随机填充提供的保护也非常少。同样，将有效负载填充到固定大小会在其长度跨越固定大小边界时暴露信息，如果攻击者可以控制明文，这种情况是可能出现的。

## 10.8. Frame Parsing

少数协议元素包含嵌套的长度元素，通常是在包含以可变长度整数编码的显式长度的帧中。这可能会给粗心的实现带来安全风险。实现必须（**MUST**）确保帧的长度与其包含的长度字段完全匹配。

## 10.9. Early Data

HTTP/3使用0-RTT会导致重放攻击。当以0-RTT机制发送HTTP/3数据时，必须（**MUST**）应用[HTTP-REPLAY]中的反重放规避措施。在HTTP/3应用[[HTTP-REPLAY]](#http-replay)时，提及的TLS是指在QUIC中的TLS握手，而提及的所有应用数据都是指流的内容。

## 10.10. Migration

某些HTTP实现使用客户端地址进行日志记录或访问控制。由于QUIC客户端的地址可能会在连接期间发生变化（并且未来版本可能支持同时使用多个地址），因此此类实现将需要主动检索客户端的当前地址或相关地址，或者明确接受初始地址可能会更改的事实。

## 10.11. Privacy Considerations

HTTP/3的几个特性为观察者提供了将单个客户端或服务端的操作随时间关联的机会。这些包括setting的值、对激励的反应时间以及对settings控制的任何功能的处理。

只要这些行为产生了可观察到的差异，它们就可以作为对特定客户进行指纹识别的基础。

HTTP/3对使用单个QUIC连接的偏好可以关联用户在站点上的活动。不同源重用连接可以关联跨这些源的活动。

有几个QUIC特性会要求立即响应，终端可以使用它来测量对端的延迟；在某些情况下，这可能对隐私有些影响。

# 11. IANA Considerations
本文注册了一个新的ALPN协议ID（第11.1节）并创建了管理HTTP/3中码点分配的新注册表。

## 11.1. Registration of HTTP/3 Identification String
本文为在[[RFC7301]](#rfc7301)中创建的“TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs”注册表中的HTTP/3标识创建了一个新的注册项。

"h3" 标识 HTTP/3:

Protocol:
HTTP/3

Identification Sequence:
0x68 0x33 ("h3")

Specification:
This document

## 11.2. New Registries

本文中创建的新注册项遵循QUIC注册策略[[QUIC-TRANSPORT]](#quic)第22.1节中的约定，都包含列在[[QUIC-TRANSPORT]](#quic)第22.1.1节中的通用字段集。这些注册项都归类在"Hypertext Transfer Protocol version 3 (HTTP/3)"标题下。

这些注册表项的初始值都为永久状态，都列出了IETF变更控制者和HTTP工作组的联系人 (ietf-http-wg@w3.org)。

## 11.2.1. Frame Types

本文为HTTP/3帧类型编码创建了一个注册表，取值为62位空间。此注册表遵循第22.1节中的注册策略。此注册表中的永久注册项遵循（[[RFC8126]](#rfc8126)第4.6节）规约策略进行分配，但0x00和0x3f（十六进制）之间的值除外，这些值使用[[RFC8126]](#rfc8126)第4.9和4.10节定义的Standards Action或IESG许可进行分配。

尽管此注册表与[[HTTP/2]](#http2)中定义的"HTTP/2 Frame Type"注册表是分开的，但在码点空间重叠的情况下，分配值最好彼此平行。如果一个条目仅存在于一个注册表中，则应该（**SHOULD**）努力避免将相应的值分配给不相关的操作。评审专家可以（**MAY**）拒绝与相应注册表中的相同值冲突的无关注册。

除了第11.2节中列出的字段外，此注册表中的永久注册项必须（**MUST**）包括以下字段：

Frame Type: 帧类型名称或标签

帧类型的定义必须包含对帧格式及其语义的描述，也必须（**MUST**）包含任何可选条件项。
表2中的条目由本文注册：

Table 2: Initial HTTP/3 Frame Types
| Frame Type | Value | Specification |
|:---|:---|:---|
| DATA | 0x00 | Section 7.2.1 |
| HEADERS | 0x01 | Section 7.2.2 |
| Reserved | 0x02 | This document |
| CANCEL_PUSH | 0x03 | Section 7.2.3 |
| SETTINGS | 0x04 | Section 7.2.4 |
| PUSH_PROMISE | 0x05 | Section 7.2.5 |
| Reserved | 0x06 | This document |
| GOAWAY | 0x07 | Section 7.2.6 |
| Reserved | 0x08 | This document |
| Reserved | 0x09 | This document |
| MAX_PUSH_ID | 0x0d | Section 7.2.7 |

形如 0x1f * N + 0x21（N为非负整数）值（即0x21， 0x40， ...， 直至0x3ffffffffffffffe）不得（**MUST NOT**）由IANA分配，也不得（**MUST NOT**）出现在分配值列表中。

## 11.2.2. Settings Parameters

本文为HTTP/3帧类型编码创建了一个注册表，取值为62位空间。此注册表遵循第22.1节中的注册策略。此注册表中的永久注册项遵循（[[RFC8126]](#rfc8126)第4.6节）规约策略进行分配，但0x00和0x3f（十六进制）之间的值除外，这些值使用[[RFC8126]](#rfc8126)第4.9和4.10节定义的Standards Action或IESG许可进行分配。

尽管此注册表与[[HTTP/2]](#http2)中定义的"HTTP/2 Frame Type"注册表是分开的，但在码点空间重叠的情况下，分配值最好彼此平行。如果一个条目仅存在于一个注册表中，则应该（**SHOULD**）努力避免将相应的值分配给不相关的操作。评审专家可以（**MAY**）拒绝与相应注册表中的相同值冲突的无关注册。

除了第11.2节中列出的字段外，此注册表中的永久注册项必须（**MUST**）包括以下字段：

Setting Name: setting的符号名称，指定setting名称是可选的。

Default: 默认值。默认值应该（**SHOULD**）严格指定。

表3中的条目由本文注册：

Table 3: Initial HTTP/3 Settings
| Setting Name | Value | Specification | Default |
|:---|:---|:---|:---|
| Reserved | 0x00 | This document | N/A |
| Reserved | 0x02 | This document | N/A |
| Reserved | 0x03 | This document | N/A |
| Reserved | 0x04 | This document | N/A |
| Reserved | 0x05 | This document | N/A |
| MAX_FIELD_SECTION_SIZE | 0x06 | Section 7.2.4.1 | Unlimited |

出于格式原因，可以删除“SETTINGS_”前缀来缩写Setting名称。

形如 0x1f * N + 0x21（N为非负整数）值（即0x21， 0x40， ...， 直至0x3ffffffffffffffe）不得（**MUST NOT**）由IANA分配，也不得（**MUST NOT**）出现在分配值列表中。

## 11.2.3. Error Codes
本文为HTTP/3帧类型编码创建了一个注册表，取值为62位空间。此注册表遵循第22.1节中的注册策略。此注册表中的永久注册项遵循（[[RFC8126]](#rfc8126)第4.6节）规约策略进行分配，但0x00和0x3f（十六进制）之间的值除外，这些值使用[[RFC8126]](#rfc8126)第4.9和4.10节定义的Standards Action或IESG许可进行分配。

尽管此注册表与[[HTTP/2]](#http2)中定义的"HTTP/2 Frame Type"注册表是分开的，但在码点空间重叠的情况下，分配值最好彼此平行。如果一个条目仅存在于一个注册表中，则应努力避免将相应的值分配给不相关的操作。评审专家可以（**MAY**）拒绝与相应注册表中的相同值冲突的无关注册。

除了第11.2节中列出的字段外，此注册表中的永久注册项必须（**MUST**）包括以下字段：

Name: 错误码名称。

Description: 错误码语义的简要描述。

表4中的条目由本文注册，本文定义的错误码遵循Specification Required策略约定的范围，尽量避免与HTTP/2的错误码项冲突： 

Table 4: Initial HTTP/3 Error Codes
| Name | Value | Description | Specification | 
|:---|:---|:---|:---|
| H3_NO_ERROR | 0x0100 | No error | Section 8.1  |
| H3_GENERAL_PROTOCOL_ERROR | 0x0101 | General protocol error | Section 8.1 |
| H3_INTERNAL_ERROR | 0x0102 | Internal error | Section 8.1 |
| H3_STREAM_CREATION_ERROR | 0x0103 | Stream creation error | Section 8.1 |
| H3_CLOSED_CRITICAL_STREAM | 0x0104 | Critical stream was closed | Section 8.1 |
| H3_FRAME_UNEXPECTED | 0x0105 | Frame not permitted in the current state | Section 8.1 |
| H3_FRAME_ERROR | 0x0106 | Frame violated layout or size rules | Section 8.1 |
| H3_EXCESSIVE_LOAD | 0x0107 | Peer generating excessive load | Section 8.1 |
| H3_ID_ERROR | 0x0108 | An identifier was used incorrectly | Section 8.1 |
| H3_SETTINGS_ERROR | 0x0109 | SETTINGS frame contained invalid values | Section 8.1 |
| H3_MISSING_SETTINGS | 0x010a | No SETTINGS frame received | Section 8.1 |
| H3_REQUEST_REJECTED | 0x010b | Request not processed | Section 8.1 |
| H3_REQUEST_CANCELLED | 0x010c | Data no longer needed | Section 8.1 |
| H3_REQUEST_INCOMPLETE | 0x010d | Stream terminated early | Section 8.1 |
| H3_MESSAGE_ERROR | 0x010e | Malformed message | Section 8.1 |
| H3_CONNECT_ERROR | 0x010f | TCP reset or error on CONNECT request | Section 8.1 |
| H3_VERSION_FALLBACK | 0x0110 | Retry over HTTP/1.1 | Section 8.1 |

形如 0x1f * N + 0x21（N为非负整数）值（即0x21， 0x40， ...， 直至0x3ffffffffffffffe）不得（**MUST NOT**）由IANA分配，也不得（**MUST NOT**）出现在分配值列表中。

## 11.2.4. Stream Types
本文为HTTP/3帧类型编码创建了一个注册表，取值为62位空间。此注册表遵循第22.1节中的注册策略。此注册表中的永久注册项遵循（[[RFC8126]](#rfc8126)第4.6节）规约策略进行分配，但0x00和0x3f（十六进制）之间的值除外，这些值使用[[RFC8126]](#rfc8126)第4.9和4.10节定义的Standards Action或IESG许可进行分配。

除了第11.2节中列出的字段外，此注册表中的永久注册项必须（**MUST**）包括以下字段：

Stream Type: 流类型名称或标签。

Sender: 发送方，在HTTP/3连接上发起此类型流的终端，取值可为：客户端、服务端、两端

永久注册项的定义必须（**MUST**）包含流类型、流格式及流内容的语义。

表5中的条目由本文注册，

Table 5: Initial Stream Types
| Stream Type | Value | Specification | Sender |
| :------| :----- | :----- |:----- |
| Control Stream | 0x00 | Section 6.2.1 | Both |
| Push Stream | 0x01 | Section 4.6 | Server |

形如 0x1f * N + 0x21（N为非负整数）值（即0x21， 0x40， ...， 直至0x3ffffffffffffffe）不得（**MUST NOT**）由IANA分配，也不得（**MUST NOT**）出现在分配值列表中。

# 12. References
## 12.1. Normative References
<a id="altsvc">[ALTSVC]</a>
Nottingham, M., McManus, P., and J. Reschke, "HTTP Alternative Services", RFC 7838, DOI 10.17487/RFC7838, April 2016, <https://www.rfc-editor.org/info/rfc7838>.

<a id="cookies">[COOKIES]</a>
Barth, A., "HTTP State Management Mechanism", RFC 6265, DOI 10.17487/RFC6265, April 2011, <https://www.rfc-editor.org/info/rfc6265>.

<a id="http">[HTTP]</a>
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP Semantics", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <https://www.rfc-editor.org/info/rfc9110>.

<a id="http-caching">[HTTP-CACHING]</a>
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP Caching", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <https://www.rfc-editor.org/info/rfc9111>.

<a id="http-replay">[HTTP-REPLAY]</a>
Thomson, M., Nottingham, M., and W. Tarreau, "Using Early Data in HTTP", RFC 8470, DOI 10.17487/RFC8470, September 2018, <https://www.rfc-editor.org/info/rfc8470>.

<a id="qpack">[QPACK]</a>
Krasic, C., Bishop, M., and A. Frindell, Ed., "QPACK: Field Compression for HTTP/3", RFC 9204, DOI 10.17487/RFC9204, June 2022, <https://www.rfc-editor.org/info/rfc9204>.

<a id="quic">[QUIC-TRANSPORT]</a>
Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based Multiplexed and Secure Transport", RFC 9000, DOI 10.17487/RFC9000, May 2021, <https://www.rfc-editor.org/info/rfc9000>.

<a id="rfc0793">[RFC0793]</a>
Postel, J., "Transmission Control Protocol", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <https://www.rfc-editor.org/info/rfc793>.

<a id="rfc2119">[RFC2119]</a>
Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.

<a id="rfc6066">[RFC6066]</a>
Eastlake 3rd, D., "Transport Layer Security (TLS) Extensions: Extension Definitions", RFC 6066, DOI 10.17487/RFC6066, January 2011, <https://www.rfc-editor.org/info/rfc6066>.

<a id="rfc7301">[RFC7301]</a>
Friedl, S., Popov, A., Langley, A., and E. Stephan, "Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301, July 2014, <https://www.rfc-editor.org/info/rfc7301>.

<a id="rfc8126">[RFC8126]</a>
Cotton, M., Leiba, B., and T. Narten, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.

<a id="rfc8174">[RFC8174]</a>
Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.

<a id="uri">[URI]</a>
Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform Resource Identifier (URI): Generic Syntax", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.


## 12.2. Informative References
<a id="breach">[BREACH]</a>
Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the CRIME Attack", July 2013, <http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.

<a id="dns-terms">[DNS-TERMS]</a>
Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499, January 2019, <https://www.rfc-editor.org/info/rfc8499>.

<a id="hpack">[HPACK]</a>
Peon, R. and H. Ruellan, "HPACK: Header Compression for HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015, <https://www.rfc-editor.org/info/rfc7541>.

<a id="http1">[HTTP/1.1]</a>
Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112, June 2022, <https://www.rfc-editor.org/info/rfc9112>.

<a id="http2">[HTTP/2]</a>
Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113, DOI 10.17487/RFC9113, June 2022, <https://www.rfc-editor.org/info/rfc9113>.

<a id="rfc6585">[RFC6585]</a>
Nottingham, M. and R. Fielding, "Additional HTTP Status Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012, <https://www.rfc-editor.org/info/rfc6585>.

<a id="rfc8164">[RFC8164]</a>
Nottingham, M. and M. Thomson, "Opportunistic Security for HTTP/2", RFC 8164, DOI 10.17487/RFC8164, May 2017, <https://www.rfc-editor.org/info/rfc8164>.

<a id="tfo">[TFO]</a>
Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014, <https://www.rfc-editor.org/info/rfc7413>.

<a id="tls">[TLS]</a>
Rescorla, E., "The Transport Layer Security (TLS) Protocol Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.

# Appendix A. Considerations for Transitioning from HTTP/2
HTTP/3受到HTTP/2的深刻影响，两者有许多相似之处。本部分介绍HTTP/3的设计方法，指出与HTTP/2的重要区别，并说明如何将HTTP/2扩展映射到HTTP/3。

HTTP/3设计尽量向HTTP/2靠拢，但不是硬性要求。HTTP/3与HTTP/2不同的，正如QUIC不同于TCP，既可充分利用QUIC的特性（如流），也可适应其大的不足（如缺失连接上的保序）。HTTP/3在流上请求和响应的关系等关键方面与HTTP/2类似，但HTTP/3设计的细节与HTTP/2有很大差异。

本部分指出了一些重要的差异。

## A.1. Streams
HTTP/3允许使用比HTTP/2更多的流（2<sup>62</sup>-1）。但关于耗尽流ID空间的考虑也是相同的，尽管HTTP/3空间大得多，使得可能首先达到QUIC中的其他限制，例如连接流控窗口的限制。

与HTTP/2不同，HTTP/3中的流并发由QUIC管理。当所有数据都已收齐，并且其发送的数据都已被对端确认时，QUIC认为流关闭。HTTP/2是在包含END_STREAM位的帧已提交给传输层时，即认为流关闭。因此，交换同等内容的话，HTTP/3的流可能在更长的时间段内保持“活动”状态。HTTP/3服务端可以根据预期的使用模式，选择允许客户端发起更多的并发双向流，以实现与HTTP/2等效。

在HTTP/2中，只有请求和响应的body内容（DATA帧的有效载荷）受流控处理。HTTP/3所有帧都在QUIC流上发送，因此所有流上承载的帧都在HTTP/3中进行流控。

由于存在其他单向流类型，HTTP/3并不完全由并发单向流的数量，来决定在途的服务端并发推送的数量，而是由客户端发送MAX_PUSH_ID帧进行控制。

## A.2. HTTP Frame Types
HTTP/2与传输有关的许多帧概念可以下沉至QUIC。由于帧已经在各自的流上发送，因此可以省略流编号。由于帧不会阻塞多路复用（QUIC的多路复用在此层之下），因此对variable-maximum-length数据包的支持可以移除。由于流关闭由QUIC处理，不再需要END_STREAM标记，因此可从通用帧格式中删除Flags字段。

帧有效载荷主要来自[[HTTP/2]](#http2)。不过因为QUIC包括HTTP/2中也存在的许多特性（如流控），HTTP/3映射不会再重复实现一次。因此，HTTP/2帧类型中有一些在HTTP/3中不再需要。这些帧ID会被保留，以便在HTTP/2和HTTP/3实现之间实现最大程度的可移植性。不过，两种映射中都出现的帧类型，其语义也不尽相同。

许多差异源于HTTP/2在整个连接的所有流上提供帧与帧之间的保序，而QUIC仅在每个流上提供这种保证。因此，如果帧类型假定需要HTTP/2这种保序传输，则HTTP/3将重新设计适配机制。

下面描述一些特性适配实例，以及将HTTP/2帧扩展转换为HTTP/3的通用指导。

### A.2.1. Prioritization Differences
HTTP/2在PRIORITY帧和HEADERS帧（可选）中指定优先级，HTTP/3不提供指示信令优先级的手段。

请注意，虽然没有明确的信令优先级，但这并不意味着优先级对于改善性能不重要。

### A.2.2. Field Compression Differences
HPACK设计的前提是按保序传输。编码后的字段区间序列必须按其编码顺序到达对端（并被解码）。这可确保两个终端的动态状态保持同步。

由于QUIC不提供此保序承诺，HTTP/3使用改版后的HPACK，称为QPACK。QPACK使用单向流发送对动态表的所有修改，从而使更新保序。包含编码字段的帧仅在给定时间引用表状态，而不能修改它。

详情参见[[QPACK]](#qpack)。

### A.2.3. Flow-Control Differences
HTTP/2定义了一套流控机制。即使所有HTTP/2帧都在流上传送，但只有DATA帧负载才受流控管理。QUIC为流数据提供流控，本文定义的所有HTTP/3帧类型都在流上发送。因此，所有帧报头和有效载荷都受流控制。

### A.2.4. Guidance for New Frame Type Definitions
HTTP/3中的帧类型定义通常使用QUIC可变长度整数编码。特别是，流ID也使用此编码，比HTTP/2中的取值范围更大。HTTP/3中的某些帧使用非流ID（例如，push ID）的标识符。如果编码中包含流ID，则可能需要重新定义扩展帧类型编码格式。

由于通用HTTP/3帧中不存在Flags字段，因此依赖Flags存在的那些帧需要为Flag分配空间，作为其帧负载的一部分。

除了上述问题之外，HTTP/2帧类型扩展通常只需将HTTP/2中的流0替换为HTTP/3中的控制流，即可移植到QUIC。HTTP/3扩展不假定连接级保序，也不受乱序影响，预期可移植到HTTP/2。

### A.2.5. Comparison of HTTP/2 and HTTP/3 Frame Types
DATA（0x00）：
HTTP/3 DATA帧中没有定义填充。请参阅7.2.1节。

HEADERS（0x01）：
HTTP/3 HEADERS帧中没有定义PRIORITY字段、没有定义填充。请参阅7.2.2节。

PRIORITY（0x02）：
如附录A.2.1所述，HTTP/3不提供信令优先级的手段。

RST_STREAM（0x03）：
HTTP/3中不存在RST_STREAM帧，因为QUIC提供流生命周期管理。CANCEL_PUSH帧使用相同的码点（7.2.3节）。

SETTINGS（0x04）：
SETTINGS帧仅在连接开始时发送。请参阅7.2.4和附录A.3。

PUSH_PROMISE（0x05）：
PUSH_PROMISE帧不引用一个流；相反，推送流中通过push ID引用PUSH_PROMISE帧。请参阅7.2.5节。

PING（0x06）：
HTTP/3中不存在PING帧，因为QUIC提供等价功能。

GOAWAY（0x07）：
GOAWAY不包含错代码。在客户端到服务端方向，它携带push ID，而不是服务端发起的流ID。请参阅7.2.6节。

WINDOW_UPDATE（0x08）：
HTTP/3中不存在WINDOW_UPDATE帧，因为QUIC提供流控。

CONTINUATION（0x09）：无效
HTTP/3中不存在连续帧；相反，允许比HTTP/2更大的HEADERS/PUSH_PROMISE帧。

如果仍然适用，则需要为HTTP/3单独注册由HTTP/2扩展定义的帧类型。为了简单起见，保留了在[[HTTP/2]](#http2)中定义的帧的ID。请注意，HTTP/3中的帧类型取值空间大得多（62位比8位），因此许多HTTP/3帧类型没有等价的HTTP/2码点。请参阅第11.2.1节。

## A.3. HTTP/2 SETTINGS Parameters
与HTTP/2的一个重要区别是，HTTP/3的SETTINGS帧作为控制流的第一个帧，只发送一次，之后不能更改。这样就避免了许多围绕同步更改的边角场景。

HTTP/2通过SETTINGS帧指定的，某些传输级别的setting，已被被HTTP/3中的QUIC传输参数取代。HTTP/3中保留的HTTP级别setting与HTTP/2中值相同。已被取代的setting是保留的，接收到此类setting要报错。有关保留值和保留值的讨论，请参阅7.2.4.1节。

以下是HTTP/2 SETTINGS参数的映射列表：

SETTINGS_HEADER_TABLE_SIZE（0x01）：
请参阅[[QPACK]](#qpack)

SETTINGS_ENABLE_PUSH（0x02）：
删除此选项，代以MAX_PUSH_ID帧，该帧可对服务端推送进行更精细的控制。在 HTTP/3 SETTINGS帧中设置标识符为0x02（对应于SETTINGS_ENABLE_PUSH参数）的setting是错误的。

SETTINGS_MAX_CONCURRENT_STREAMS（0x03）：
QUIC管理最大打开流ID，作为其流控逻辑的一部分。在 HTTP/3 SETTINGS帧中设置标识符为0x03的setting（对应于SETTINGS_MAX_CONCURRENT_STREAMS参数）是错误的。

SETTINGS_INITIAL_WINDOW_SIZE（0x04）：
QUIC要求在初始传输握手中指定流和连接的流控窗口大小。在 HTTP/3 SETTINGS帧中设置标识符为0x04的setting（对应于SETTINGS_INITIAL_WINDOW_SIZE参数）是错误的。

SETTINGS_MAX_FRAME_SIZE（0x05）：
此setting在HTTP/3中没有等价项。在 HTTP/3 SETTINGS帧中设置标识符为为0x05的setting（对应参数SETTINGS_MAX_FRAME_SIZE）是错误的。

SETTINGS_MAX_HEADER_LIST_SIZE（0x06）：
此setting标识符已重命名SETTINGS_MAX_FIELD_SECTION_SIZE。

在HTTP/3中，setting值是可变长度整数（6、14、30或62位），而不是HTTP/2中的固定长度32位。这通常产生较短的编码，但使用32位取值空间的setting会产生更长的编码。从HTTP/2移植过来的setting可以选择重新定义其值，将其限制为30位进行更高效的编码，或者在需要超过30位的情况下使用62位空间。

需要为HTTP/2和HTTP/3分别定义setting。为简化起见，保留了[[HTTP/2]](#http2)中定义的setting ID。请注意，HTTP/3中的setting标识符空间大得多（62位比16位），因此许多HTTP/3 setting没有等价的HTTP/2码点。请参阅第11.2.2节。

由于QUIC流可能乱序，建议终端不要等待对端的setting到达之后再响应其他流。请参阅7.2.4.2节。

## A.4. HTTP/2 Error Codes
QUIC对“流”和“连接”级错误的定义与HTTP/2一样。不过，HTTP/2和HTTP/3之间的差异，意味着两个版本间的错误码不会直接迁移。

[[HTTP/2]](#http2)第7章中定义的HTTP/2错误码与HTTP/3错误码的逻辑映射如下所示：

NO_ERROR（0x00）：
H3_NO_ERROR 参见第8.1节。

PROTOCOL_ERROR（0x01）：
映射到H3_GENERAL_PROTOCOL_ERROR，除非有更具体的错误码。如第8.1节中定义的H3_FRAME_UNEXPECTED、H3_MESSAGE_ERROR和H3_CLOSED_CRITAL_STREAM。

INTERNAL_ERROR（0x02）：
参见第8.1节的H3_INTERNAL_ERROR。

FLOW_CONTROL_ERROR（0x03）：
不适用，因为QUIC处理流控。

SETTINGS_TIMEOUT（0x04）：
不适用，因为未定义SETTINGS的确认。

STREAM_CLOSED（0x05）：
不适用，因为QUIC处理流管理。

FRAME_SIZE_ERROR（0x06）：
FRAME_SIZE_ERROR，在第8.1节定义。

REFUSED_STREAM（0x07）：
部分映射，H3_REQUEST_REJECTED（第8.1节）用于指示某个请求未被处理。其他情况不适用，因为QUIC进行流管理。

CANCEL（0x08）：
参见H3_REQUEST_CANCELLED。

COMPRESSION_ERROR（0x09）：
[[QPACK]](#qpack)中定义了多个相关错误码。

CONNECT_ERROR（0x0a）：
参见第8.1节的H3_CONNECT_ERROR。

ENHANCE_YOUR_CALM（0x0b）：
参见第8.1节的H3_EXCESSIVE_LOAD。

INADEQUATE_SECURITY（0x0c）：
不适用，因为假定QUIC已为所有连接提供了足够的安全性。

HTTP_1_1_REQUIRED（0x0d）：
参见第8.1节的H3_VERSION_FALLBACK。

需要分别定义的HTTP/2和HTTP/3错误码请参阅第11.2.3节。

## A.4.1. Mapping between HTTP/2 and HTTP/3 Errors
在HTTP/2和HTTP/3之间转换的中间设备可能需要传递上层错误条件，将错误的发生告知下层是有必要的，但错误码在很大程度上反映的是连接局部问题，这些问题通常没有传播的意义。

从上游来源收到错误码的中间设备，可以通过发送HTTP状态码（例如502（BadGateway））来指示这一点，该状态码适合于广泛的一类错误。

在少数情况下，对接收方来说，通过将错误映射到最接近的错误类型是有帮助的。例如，中间设备从HTTP/2源接收到流REFUSED_STREAM错误，表明请求未被处理、可以安全重试的信号，将此作为H3_REQUEST_REJECTED类型的HTTP/3流错误，发送到客户端，使得客户端可以执行其认为最适当的操作。在相反的方向上，中间设备可以用H3_REQUEST_CANCELLED错误关闭数据流，来传递客户请求取消的信号，见4.1.1节。

上节逻辑映射中描述了错误之间的转换关系。错误码定义空间不重叠，能防止意外转换导致对目标版本使用错误或未知的错误码。允许中间设备将流错误提升为连接错误，但其应知道对暂时或间歇性错误的话，这种处理对HTTP/3连接的成本有点大（可能导致连接关闭）。
